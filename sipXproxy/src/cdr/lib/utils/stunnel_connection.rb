#
# Copyright (C) 2006 SIPfoundry Inc.
# Licensed by SIPfoundry under the LGPL license.
# 
# Copyright (C) 2006 Pingtel Corp.
# Licensed to SIPfoundry under a Contributor Agreement.
#
##############################################################################

require 'utils/call_resolver_configure'
require 'utils/configure'
require 'db/database_url'
require 'utils/exceptions'
require 'utils/utils'

# Attempts to open stunnel connections to all configured distributed machines.
class StunnelConnection
  
  attr_reader :log
  
  # Constants
  LOCALHOST = 'localhost'
  
  STUNNEL_CONFIG_FILE = 'stunnel-config.tmp'
  STUNNEL_EXEC = '/usr/sbin/stunnel'
  
  ERROR_OUT = "Error: "
  
  CSE_STUNNEL_DEBUG_LEVEL = 'SIP_CALLRESOLVER_STUNNEL_DEBUG'
  
  # Default debug level NOTICE  
  CSE_STUNNEL_DEBUG_LEVEL_DEFAULT = '5'
  CSE_CONNECT_PORT = '9300'
  
  # No default for the CA file name - if HA is configured this has to be set
  CSE_CA = 'SIP_CALLRESOLVER_CSE_CA'
  
  SIGNAL_SIGQUIT = 3
  SIPXPBX_SSLPATH = 'etc/sipxpbx/ssl'
  
  public
  
  def initialize(log)
    @log = log
    @prefix = ENV['SIPX_PREFIX']
    @pid = nil
  end
  
  def open(config)
    # Look up the config param and generate the stunnel config file.
    # Set the @ha_enabled variable depending on if any distributed
    # machines were configured.
    get_stunnel_config(config)
    
    # Open stunnel connection if HA is enabled
    return unless @ha_enabled
    
    @pid = check_stunnel_running
    
    if @pid    
      raise_exception("An instance of stunnel is already running with Pid #{@pid}. It must be shut " +
                        " down before restarting the call resolver.")
    end                        
    fork do exec("#{STUNNEL_EXEC} #{STUNNEL_CONFIG_FILE}") end
    # Give stunnel time to start up
    sleep 1
    @pid = check_stunnel_running
    
    raise_exception("stunnel could not be started.") unless @pid
  end
  
  def close
    return unless @pid
    log.debug {"StunnelConnection.close: Killing pid #{@pid}"}
    Process.kill(SIGNAL_SIGQUIT, @pid.to_i)
    File.delete("#{STUNNEL_CONFIG_FILE}")
  end
  
  private
  
  # Get possible distributed CSE hosts from configuration file. Generate
  # an stunnel configuration script and return an array of ports.
  def get_stunnel_config(config)
    @ha_enabled = config.ha?
    # Nothing to do if not HA
    return if !@ha_enabled
    
    # get the name of the CA file - no defaults here, must be specified
    ca_file = config[CSE_CA]
    err_msg = "No CA file name specified. If hosts other than \"localhost\" " +
                "are specified in #{CallResolverConfigure::CSE_HOSTS}, then the " +
                "parameter #{CSE_CA} must be set to the CA file name."
    if ca_file == nil
      raise_exception(err_msg, ConfigException)
    else
      ca_file = ca_file.strip       
      if ca_file.length == 0
        raise_exception(err_msg, ConfigException)
      end
    end
    
    # Test if file exists
    if ! test(?e, "#{@prefix}/#{SIPXPBX_SSLPATH}/authorities/#{ca_file}")
      err_msg = "CA file \"#{@prefix}/#{SIPXPBX_SSLPATH}/authorities/#{ca_file}\" does not exist."
      raise_exception(err_msg, ConfigException)
    end
    
    debug_level = config[CSE_STUNNEL_DEBUG_LEVEL] || CSE_STUNNEL_DEBUG_LEVEL_DEFAULT
    generate_stunnel_config(config.host_list, config.host_port_list, ca_file, debug_level)
  end
  
  # Generate the stunnel configuration based on the call resolver configuration  
  def generate_stunnel_config(host_list, port_list, ca_file, debug_level)
    config_file = File.new("#{STUNNEL_CONFIG_FILE}",  "w")
    log.debug {"Master machine stunnel configuration:"}
    config_file.puts "# This file was generated by call_resolver.rb"
    config_file.puts "client = yes"
    config_file.puts "CAfile = #{@prefix}/#{SIPXPBX_SSLPATH}/authorities/#{ca_file}"
    config_file.puts "cert = #{@prefix}/#{SIPXPBX_SSLPATH}/ssl.crt"
    config_file.puts "key = #{@prefix}/#{SIPXPBX_SSLPATH}/ssl.key"
    config_file.puts "verify = 2"
    config_file.puts "debug = #{debug_level}"
    config_file.puts "output = #{@prefix}/var/log/sipxpbx/sipstunnel.log"
    
    log.debug {"CAfile = #{@prefix}/#{SIPXPBX_SSLPATH}/authorities/#{ca_file}"}    
    log.debug {"cert = #{@prefix}/#{SIPXPBX_SSLPATH}/ssl.crt"}
    log.debug {"key = #{@prefix}/#{SIPXPBX_SSLPATH}/ssl.key"}
    log.debug {"debug = #{debug_level}"}
    
    host_list.each_with_index do |host, i|
      # Don't generate entry for localhost
      if host_list[i] != LOCALHOST
        config_file.puts ""
        config_file.puts "[Postgres-#{i}]"
        config_file.puts "accept = #{port_list[i]}"
        config_file.puts "connect = #{host}:#{CSE_CONNECT_PORT}"
        log.debug {"accept = #{port_list[i]}"}
        log.debug {"connect = #{host}:#{CSE_CONNECT_PORT}"}
      end
    end
    config_file.close()
  end
  
  def check_stunnel_running()
    shellReturn = `ps -fC stunnel | grep #{STUNNEL_EXEC}`
    shellReturn.strip!
    if /\A\D+\s+(\d+)\s+.*stunnel.*/ =~ shellReturn
      $1
    end      
  end
  
  def raise_exception(err_msg, klass = CallResolverException)
    puts "Error: #{err_msg}"
    Utils.raise_exception(err_msg, klass)
  end
  
end
