


                       sipXpbx High Availability


Table of Contents

   1.  Motivation and Overview  . . . . . . . . . . . . . . . . . . .  2
   2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  2
   3.  High Availability Architecture . . . . . . . . . . . . . . . .  2
   4.  Current Registrar/Redirect Database Management . . . . . . . .  4
     4.1.  Registry Updates . . . . . . . . . . . . . . . . . . . . .  4
     4.2.  Locking  . . . . . . . . . . . . . . . . . . . . . . . . .  6
   5.  Changes  . . . . . . . . . . . . . . . . . . . . . . . . . . .  6
     5.1.  Configuration  . . . . . . . . . . . . . . . . . . . . . .  6
     5.2.  Registry Synchronization State . . . . . . . . . . . . . .  6
     5.3.  Registration Database  . . . . . . . . . . . . . . . . . .  8
       5.3.1.  Additional DB Columns  . . . . . . . . . . . . . . . .  8
       5.3.2.  Overall DB Structure . . . . . . . . . . . . . . . . .  8
     5.4.  Thread Structure and Locking . . . . . . . . . . . . . . .  9
     5.5.  Primary and Secondary Registrars . . . . . . . . . . . . .  9
     5.6.  Processing . . . . . . . . . . . . . . . . . . . . . . . . 10
       5.6.1.  RegisterServer -- Register Message Processing  . . . . 10
       5.6.2.  RegisterSync -- Sending Updates to the Peer Server . . 11
         5.6.2.1.  Detailed Operation . . . . . . . . . . . . . . . . 11
         5.6.2.2.  registrySync.pushUpdates method  . . . . . . . . . 13
         5.6.2.3.  registrySync.pullUpdates method  . . . . . . . . . 14
       5.6.3.  RegisterTest -- Peer Reachability  . . . . . . . . . . 15
         5.6.3.1.  registrySync.Check method  . . . . . . . . . . . . 16
       5.6.4.  Startup Processing . . . . . . . . . . . . . . . . . . 16
     5.7.  XML-RPC Security . . . . . . . . . . . . . . . . . . . . . 17
     5.8.  HTTP Persistent Connections  . . . . . . . . . . . . . . . 18
     5.9.  Authorization Proxy Record-Route . . . . . . . . . . . . . 18
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 19



















Lawrence, et al.                                                [Page 1]

                               sipXpbx HA                  December 2005


1.  Motivation and Overview

   For large systems, defined as PBXs with more than a few dozen users,
   high availability (HA) for basic calling is essential: users should
   be able to make and receive phone calls reliably at all times.  HA
   for voice mail, and perhaps some other services, is a lower priority
   although still important.

   * In order to deliver HA as quickly as possible, we will start by
   implementing only those features that are absolutely required.  The
   first HA implementation in sipXpbx release 3.2 will only address
   basic calling.  Automated installation will not be supported; some
   custom, manual configuration will be required.  No more than 2
   registrars will be allowed. *

   In sipXpbx, basic calling depends on three components: the two
   proxies and the registrar/redirect service.  The proxies can be
   replicated and DNS SRV records can be used to share load and provide
   for failover.  The registrar/redirect service, however, cannot
   currently be deployed on multiple servers because the 'soft' state in
   the registry database (mappings from registered Addresses to
   Contacts) cannot be shared.  While replicating the proxies alone does
   help with scaling, the registrar is a single point of failure for
   basic calling service.

   This memo describes a system architecture to provide high
   availability service for basic calling, by adding the required
   replication of registration information.


2.  Terminology
   Server A physical computer system.
   Service A process or processes running on a Server that performs a
      particular function.
   Primary Registrar For a particular REGISTER request, the registrar
      that receives it and performs initial processing for it.  Note
      that the Primary Registrar may not be the same for successive
      REGISTER requests, even from one UA.
   Replicated Registrar For a particular REGISTER request, any registrar
      other than its Primary Registrar to which its information is
      replicated.


3.  High Availability Architecture

   In an HA configuration, there are at least two types of Server:





Lawrence, et al.                                                [Page 2]

                               sipXpbx HA                  December 2005


      one Master Server running:
         forking proxy
         authentication proxy
         registrar/redirect service
         config service
         vxml service with applications
         publisher (status server)
         presence
      one or more Distributed Servers, each running:

   Other PBX Services may be distributed among the above Servers, or run
   on other Servers:

   * In Release 3.2, only one configuration will be supported: one
   Distributed Server running only the proxies and registrar/redirect
   service, and one Master Server running all Services. *

   In order to provide load sharing and failover, all SIP message
   routing to any redundant element in an HA configuration uses DNS SRV
   records.  The following SRV records are required:
   domain In a single-system installation, an SRV record that maps the
      SIP domain name to the Server host name is recommended.  In an HA
      installation, multiple SRV records for the SIP domain name are
      required, mapping to the Server names/ports that run the forking
      proxy service.  There are domain SRV records specifying both TCP
      and UDP (with TCP given preference).  For example:

         $ORIGIN example.com.

         _sip._tcp IN SRV   1 50 5060 sipxpbx1
         _sip._tcp IN SRV   1 50 5060 sipxpbx2

         _sip._udp IN SRV 101 50 5060 sipxpbx1
         _sip._udp IN SRV 101 50 5060 sipxpbx2

   registrar The "forwardingrules.xml" for each forking proxy service
      specifies the registrar using an SRV name that maps first to the
      registrar instance on the same Server as the proxy (which is
      quicker to reach and more likely to be operational), and then to
      the registrar instance on the other Server (for failover).  The
      registrar service SRV records specify only TCP, because TCP has
      better failure detection and performance characteristics and
      compatibility with User Agents is not required.

        _sip._tcp.sipxregistrar1 IN SRV 1 50 5070 sipxpbx1
        _sip._tcp.sipxregistrar1 IN SRV 2 50 5070 sipxpbx2

        _sip._tcp.sipxregistrar2 IN SRV 1 50 5070 sipxpbx2



Lawrence, et al.                                                [Page 3]

                               sipXpbx HA                  December 2005


        _sip._tcp.sipxregistrar2 IN SRV 2 50 5070 sipxpbx1

      In the example above, the forking proxy on "sipxpbx1" would be
      configured to use "sipxregistrar1", which preferentially routes to
      "sipxpbx1:5070" and fails over to "sipxpbx2:5070".  The forking
      proxy on "sipxpbx2" is configured to use "sipxregistrar2", which
      uses the two Services in the reverse order.
   authproxy The "forwardingrules.xml" for each forking proxy service
      specifies the authorization proxy using a specialized SRV name
      configured similarly to the SRV name for the registrar.  The
      authorization proxy SRV records specify both TCP and UDP,
      preferring TCP, but allowing UDP for compatibility with User
      Agents that require it.  (The authorization proxy may be Record-
      Routed in dialogs.)

         _sip._tcp.sipxauthproxy1 IN SRV   1 50 5080 sipxpbx1
         _sip._tcp.sipxauthproxy1 IN SRV   2 50 5080 sipxpbx2
         _sip._udp.sipxauthproxy1 IN SRV 101 50 5080 sipxpbx1
         _sip._udp.sipxauthproxy1 IN SRV 102 50 5080 sipxpbx2

         _sip._tcp.sipxauthproxy2 IN SRV   1 50 5080 sipxpbx2
         _sip._tcp.sipxauthproxy2 IN SRV   2 50 5080 sipxpbx1
         _sip._udp.sipxauthproxy2 IN SRV 101 50 5080 sipxpbx2
         _sip._udp.sipxauthproxy2 IN SRV 102 50 5080 sipxpbx1

      The selection technique used to create a preference order for
      registrars is also used for the authproxy, except that SRV records
      for UDP access are also provided, at lower priority than all the
      SRV records for TCP access.
      * Currently, when the authproxy Record-Routes itself, it specifies
      its IP address in the Record-Route header.  The authproxy could
      insert a Record-Route that specifies its SRV name (as detailed
      above); doing so would allow the processing of in-dialog requests
      to fail over from one instance to another.  Whether or not the
      authproxy should do this depends on whether or not user agents
      support DNS names in Route headers.  Testing is required to
      determine the best method for Record-Routing. *


4.  Current Registrar/Redirect Database Management

   This section describes the operation of the registrar in sipXpbx
   version 3.0.  It does not describe HA changes, or the changes for
   GRUU support.

4.1.  Registry Updates

   Updating the registry is handled by the routine SipRegistrarServer::



Lawrence, et al.                                                [Page 4]

                               sipXpbx HA                  December 2005


   applyRegisterToDirectory and the sibdb RegistrationDB class.  The
   applyRegisterToDirectory method is called after the REGISTER request
   has been authenticated; it validates the registration by checking to
   see if the Call-ID and CSeq are in sequence by calling
   RegistrationDB::isOutOfSequence.

   applyRegisterToDirectory then parses and validates the contacts and
   expiration time in the request and converts them to an internal list.

   If the request is valid, there are two cases: expiring all contacts,
   and updating contacts.
   Expiring All Contacts If the REGISTER request had an '"Expire: 0"'
      header and just a '"Contact: *"' header then it is requesting that
      all contacts for this Address Of Record (not just those from this
      Call-ID) be expired.  This is done using a single call to:

          RegistrationDB::expireAllBindings( aor, callid, cseq, timeNow )

      The last three arguments to expireAllBindings are not used to
      select which bindings to operate on.  (All bindings for the given
      AOR are expired.)  Rather, they are used for marking the bindings
      as expired -- Bindings are expired by setting their expiration
      time to "timeNow minus 1 second", and setting their "last updated
      by" information to the Call-ID and CSeq specified.
   Updating Contacts The other case is when there are real contacts in
      the set.  All contacts which are listed are to have their
      expiration times updated, and all other contacts which have last
      been updated with by REGISTERs with this Call-ID are to be
      expired.
      The listed contacts are updated by calling RegistrationDB::
      updateBinding on each contact:

         RegistrationDB::updateBinding( toUrl,
                                        contact,
                                        qvalue,
                                        registerCallidStr,
                                        registerCseqInt,
                                        expirationTime
                                        )

      Each contact has its q-value and expiration time set, and the
      Call-ID and CSeq are recorded as its "last updated by"
      information.
      After all the contacts in the REGISTER message have been updated,
      any contacts that have the same Call-ID but an earlier CSeq number
      are expired by a single call to:





Lawrence, et al.                                                [Page 5]

                               sipXpbx HA                  December 2005


                 RegistrationDB::expireOldBindings( toUrl,
                                                    registerCallidStr,
                                                    registerCseqInt,
                                                    timeNow
                                                    )

4.2.  Locking

   Other than the locks internal to FastDB, there are no locks on any of
   the above operations.  This works because only the single
   SipRegistrarServer thread ever writes to the registry database.


5.  Changes

   The following sections detail the changes needed to implement the
   replicated registrar architecture.

5.1.  Configuration

   An HA Registrar has two additional configuration parameters:
   SIP_REGISTRAR_SYNC_WITH The host name of the other registrar to sync
      to. ( _In future versions, this may allow a comma-separated list
      of Servers._)
   SIP_REGISTRAR_XMLRPC_PORT The port number used by all Servers to
      listen for XML-RPC registry synchronization requests.

   _The set of configuration parameters may be changed in future
   versions of the HA system.  Compatibility is only guaranteed with
   those sipXconfig versions which support HA._

5.2.  Registry Synchronization State

   The Registrar Service maintains persistent (across start-ups) state
   for synchronization purposes:
   DbUpdateNumber A numeric ID for update operations to its own registry
      database.  DbUpdateNumber is updated only for registrations for
      which this registrar is the Primary Registrar.

   DbUpdateNumber is a positive, signed, 64-bit number composed of two
   parts:
   base time The "base time" component in the upper half of
      DbUpdateNumber is a Unix time value, the number of seconds since
      00:00 GMT, 1 January 1970.  It is the time at which the registrar
      last initialized the counter component.  Since all Servers are
      expected to have reliable, NTP-synchronized clocks, base times
      created by a Service always increase.  Since initializations of
      the update number are expected to be rare, all base times in a



Lawrence, et al.                                                [Page 6]

                               sipXpbx HA                  December 2005


      system are unique.  The base time is a 32-bit, positive, signed
      integer.
   counter The "counter" component in the bottom half of DbUpdateNumber
      is a 32-bit unsigned integer that is incremented on every update.

   We need to be able to compare DbUpdateNumbers and decide which one is
   more recent.  However, at 1,000 updates/second, a 32-bit counter will
   wrap in 1.6 months.  Because registrations don't stay valid for very
   long (typically 1 hour), the range of DbUpdateNumbers at any point in
   time is pretty narrow, so we could treat DbUpdateNumbers as cyclic,
   looking at the absolute value of the difference of two numbers to see
   which one is larger.  But this gets complicated.  We can avoid this
   cleverness using a simple trick: rather than wrapping the counter,
   instead carry the overflow bit into the base time value, effectively
   turning the 32-bit counter into a 64-bit counter that will wrap in
   292,471,209 years -- not a problem.  Base time changes due to
   overflow can easily be distinguished from base time resets due to
   service restarts, which will increment the base time by much more
   than a few seconds.

   This design allows us to generate unique, monotonic DbUpdateNumbers
   even if we've lost the history for a registry.  If that happens, then
   we initialize the base time to the current time and the update number
   to zero.  Since the new base time is both most significant and bigger
   than any previous base times, the new DbUpdateNumbers will be bigger
   than any previous DbUpdateNumbers.

   A DbUpdateNumber is used to label the DB records that are modified by
   a DB update, and can be used to designate a particular state of the
   DB, namely, all record modifications with DbUpdateNumber less than or
   equal to some specified DbUpdateNumber.

   Since registration state is preserved across restarts, the base time
   of the local DbUpdateNumber will usually not be the same as the start
   time of the current registrar instance.  In general, the base time
   will be the earliest start time from which registration state has
   been kept.

   For a given registrar, DbUpdateNumbers for registrations that it
   handles as the primary registrar are referred to as "local".
   DbUpdateNumbers for registrations handled by other registrars and
   received via updates are referred to "peer".
   PeerReceivedDbUpdateNumber The largest DbUpdateNumber received from
      the peer.







Lawrence, et al.                                                [Page 7]

                               sipXpbx HA                  December 2005


   PeerSentDbUpdateNumber The largest DbUpdateNumber sent to the peer.

   The registrar service maintains additional state that is not
   persistent:
   PeerReachable This is a boolean that indicates whether or not the
      peer is believed to be reachable.  It is initialized on startup to
      "false", indicating that the peer is not known to be reachable.
      It is set to "false" by most operations if they fail to reach the
      peer, and is set to "true" the RegisterTest thread (see
      Section 5.6.3) when it discovers that it can reach the peer.  When
      it is "false", most operations do not attempt to contact the peer.

5.3.  Registration Database

5.3.1.  Additional DB Columns

   Each row in the registration database (which corresponds to a binding
   of a contact URI to an AOR) gains two columns:
   Primary A string which is the identifier of the Primary Registrar for
      this binding.  This identifier is selected by the Primary
      Registrar, and will usually be the host name of its Server, but
      the only requirement is that each registrar has a distinct
      identifier.
   UpdateNumber The DbUpdateNumber (of the Primary Registrar's DB) of
      the update which inserted or last modified this row.

5.3.2.  Overall DB Structure

   The entries in the registration database maintain the state for
   registrations of contacts for Addresses Of Record.  Entries are
   indexed by AOR, contact, and the Call-ID of the sequence of REGISTERs
   (the registration quasi-dialog) that establish and maintain the
   registration.

   Entries are considered to have expired when the current time exceeds
   the expiration time recorded in the entry.  The entry is not removed
   at that time, so that the entry can maintain the "last CSeq seen"
   value for that Call-ID, in case an out-of-sequence REGISTER arrives.
   Entries are removed from the DB after one hour after they expire, as
   we assume that is long enough that out-of-order REGISTERS will no
   longer be in transit.

   When a registration is to be expired in advance of its previously
   scheduled expiration time (due to the processing of some REGISTER
   message), its DB entry is modified by reducing its expiration time to
   one second before the current time.

   Each entry contains the following fields.  (The fields for GRUU



Lawrence, et al.                                                [Page 8]

                               sipXpbx HA                  December 2005


   support are not listed, but they do not affect any of the replication
   algorithms.)
   uri The AOR of this registration.
   contact The contact of this registration.
   qvalue The q-value of this registration.
   callid The Call-ID of the REGISTERs that establish/maintain this
      registration.
   cseq The largest CSeq seen for REGISTERs for this registration.
   instance_id The "+sip.instance" value that was provided with the
      registration, or the null string.
   gruu The GRUU that was assigned to this registration, or the null
      string.
   primary The name of the Primary Registrar for this registration.
   update_number The DbUpdateNumber of the last modification of this
      entry.

5.4.  Thread Structure and Locking

   There are three threads in each registrar:
   RegisterServer This thread processes incoming REGISTER messages,
      applying the necessary updates to the DB, and notifying
      RegisterSync thread that when it needs to propagate updates.
   RegisterSync This thread is the XML-RPC client that sends updates to
      the peer server.
   RegisterTest This thread is the XML-RPC client that tests, when the
      peer Service is thought to be down or unreachable, whether it is
      now reachable.
   HttpServer This thread is the XML-RPC server.  It must be a separate
      from the XML-RPC client to avoid multi-Server XML-RPC deadlock
      chains.

   Registry database updates are protected by an OsMutex; it is taken by
   applyRegisterToDirectory and by each of the registrySync XML-RPC
   server methods.  This serializes all the checks for CSeq correctness,
   and also protects the synchronization state variables.

   The XML-RPC client threads (RegisterSync and RegisterTest) will also
   hold the lock when they are modifying the synchronization state, but
   never while they are making XML-RPC calls, in order to avoid mult-
   Server deadlocks.

   _ There is no locking between updates to the registry database and
   reads from it by the redirect service; the FastDB ensures sufficient
   integrity that none is needed. _

5.5.  Primary and Secondary Registrars

   Every registrar has a unique name, known by all registrars, which



Lawrence, et al.                                                [Page 9]

                               sipXpbx HA                  December 2005


   will usually be its host name.  Every REGISTER is processed by the
   registrar that first receives it, which is called the Primary
   Registrar for the REGISTER, and the Primary Registrar is said to
   "own" that registration and the records describing it (in every
   registrar database).  Each Primary Registrar has a set of Replicated
   Registrars that should contain duplicates of all registrations owned
   by that Primary Registrar.  Each registrar knows all of the
   Replicated Registrars for the registrations it owns, and also all of
   the Primary Registrars for which it is a Replicated Registrar.  In
   addition, each registrar knows the list of its "sibling Replicated
   Registrars", which includes the registrars listed above, and also the
   registrars which are Replicated Registrars for a Primary Registrar
   for which this registrar is a Replicated Registrar.

5.6.  Processing

   Registrar processing is performed in two stages -- startup and
   operational.  During the startup stage, the registrar recovers its
   local database (if possible), then pulls information from all of its
   sibling registrars.  During the operational stage, the registrar
   processes REGISTERs and pushes updates from siblings.

   The central feature of this design is that during startup and
   reconstruction of the database, the registrar pulls data, so that it
   can tell when it has finished obtaining the data it desires.  But
   during the operational phase, updates are pushed by the Primary
   Registrar to ensure that they are propagated to the Replicated
   Registrars quickly.

   The only way a Replicated Registrar can transition from being "dead"
   to being "live" (in the eyes of its Primary Registrar) is through an
   XML-RPC from the Replicated Registrar to the Primary Registrar that
   provides a PeerReceivedDbUpdateNumber for that Replicated Registrar.
   .

   Processing is done by a number of interlocking operations which are
   detailed below.  Synchronization between registrars is done using
   XML-RPC (see Section 5.6).  The XML-RPC URI for these operations
   always has scheme "https" (see Section 5.7), the host name specified
   by the SIP_REGISTRAR_SYNC_WITH configuration item, and the fixed path
   "/RPC2".

5.6.1.  RegisterServer -- Register Message Processing

   When a REGISTER message has been determined to be valid, the local DB
   update number is incremented, and the changes are applied to the
   local registry database.  The local DbUpdateNumber is recorded in
   each updated row in the registry database.  The SipRegistrarServer



Lawrence, et al.                                               [Page 10]

                               sipXpbx HA                  December 2005


   thread then sends a PushRegistryUpdate OsMessage to the RegisterSync
   thread to trigger replication to the peer registrar.

   In all cases, the Primary Registrar first reduces the effect of the
   REGISTER to the insertion/modification of a number of entries in the
   DB.  The entries are then tagged with the Call-ID/CSeq of the
   REGISTER request, and the local DbUpdateNumber of the new version of
   the DB.  It is these records that are then propagated to the
   Replicated Registrar.

   This transformation of the REGISTER before propagation is not
   absolutely correct according to RFC 3261, as it does not process
   "expire all" operations correctly in certain uncommon race
   situations, but it ensures that the results of replication are
   accurately defined (since the processing of the DB updates will
   produce the same result regardless of the order in which they are
   processed).  Even in cases where the RFC 3261 result is not produced,
   the result is always the same as would be produced by the same
   messages if they were received with certain small changes in their
   arrival times.  In other words, the race condition already exists in
   3261, and the registry replication does not introduce any problems
   that were not already there.

5.6.2.  RegisterSync -- Sending Updates to the Peer Server

   The RegisterSync thread is responsible for propagating updates to the
   peer registrar. _(When multiple peers are supported, there may be one
   thread per peer or just one for all peers -- this is a subject for
   future study.)_

   When the RegisterSync thread receives a PushRegistryUpdate message,
   it checks the peer state: If PeerReachable is "true", and if the
   local DbUpdateNumber is greater than the PeerSent DbUpdateNumber,
   then registerSync.pushUpdates XML-RPC method is used to propagate all
   updates that have not been sent to the peer (one invocation per
   unsent transaction).  After a successful return of the XML-RPC, the
   PeerSent DbUpdateNumber is updated.

5.6.2.1.  Detailed Operation

   registrySync.pushUpdates is used by one Registrar to push updates to
   its peer registrar.  It is initiated by the RegisterSync thread when
   it is notified that there are (may be) updates in the local DB for
   which it is the Primary Registrar and which have not been propagated
   to the peer registrar.

   First, RegisterSync checks the peer state: If PeerReachable is
   "false", it immediately terminates processing the PushRegistryUpdate



Lawrence, et al.                                               [Page 11]

                               sipXpbx HA                  December 2005


   message.  (The updates that need to be sent will be sent when
   RegisterTest detects that the peer registry is reachable.)

   Next, the RegisterSync thread checks that the local DbUpdateNumber is
   greater than the PeerSent DbUpdateNumber.  If not, there are no
   updates to propagate, and the thread terminates processing the
   message.

   If there are updates to propagate, the RegisterSync thread extracts
   all records in the local DB that were updated by this registrar as
   the Primary Register, and whose DbUpdateNumbers are greater than the
   PeerSent DbUpdateNumber.  These records are packaged into one or more
   registrySync.pushUpdates XML-RPC calls which are sent in succession
   to the peer registrar.

   The XML-RPC server of the peer registrar -- which must be the
   Replicated Registrar for these updates -- first validates that the
   DbUpdateNumber in the XML-RPC is greater than its PeerReceived
   DbUpdateNumber.  If not, this XML-RPC is a duplicate of one received
   previously, and the call can be returned successfully without any
   further work.

   The server then applies the updates to its DB in the standard manner.
   That is, it validates that the local database does not have more
   recent information (using the Call-ID and CSeq values) and if not,
   applies each update to its own database.  These updates do not
   increment the local DB update number (since they do not need to be
   identified), and there is no need to trigger this registrar's
   RegisterSync thread to propagate the updates further.

   The server then updates its PeerReceived DbUpdateNumber and returns
   the request successfully.

   The server also checks its PeerReachable status for the client; if it
   is "false", then the server knows that the peer is now reachable
   again, and so it sets its PeerReachable status for the client to
   "true" and sends a PushRegistryUpdate OsMessage to its RegistrySync
   thread.

   When the XML-RPC returns, the client updates its PeerSent
   DbUpdateNumber, and continues with the next set of updates to be
   sent, or finishes with the PushRegistryUpdate message.  This allows
   the registrar to know reliably what has been pushed to the peer,
   since a lost response will cause the update to be re-sent.

   On any registrySync.pushUpdates failure, the client sets its
   PeerReachable value to "false", and sends a PeerUnReachable OsMessage
   to the RegisterTest thread.



Lawrence, et al.                                               [Page 12]

                               sipXpbx HA                  December 2005


5.6.2.2.  registrySync.pushUpdates method

   This XML-RPC is used by a registrar during operation to send one or
   more updates that it owns to a Replicated Registrar.

   If this XML-RPC fails, the client will mark the server as being
   "dead".

   Alternatively, if the server is in the first startup stage, it will
   return an indication, and the client will also mark the server as
   being "dead" to avoid sending further updates which cannot be
   effectively processed during the first startup stage.

   It is not yet decided whether a Push Updates can contain updates with
   more than one update number.

   The server registrar will apply the updates to its database, and if
   its Last Update Number Received is no less than the starting update
   number, will set its Last Update Number Received to the ending update
   number.

   If the server registrar has the client registrar marked "dead", it
   will mark it "live" and queue a Push Updates operation for it.

   Inputs:

        String  registrar_name          Calling registrar name
        int     start_update_number     Update number for first update sent
        int     end_update_number       Update number for last update sent
        array   updates
          struct
            string  uri
            string  callid
            int     cseq
            string  contact
            int     expires
            string  qvalue
            string  instance_id
            string  gruu
            string  primary
            long long int update_number

   Outputs:

        none

   TBD -- The intent of return values was to inform the caller that
   there were unpropagated updates, but I'm not sure that there is



Lawrence, et al.                                               [Page 13]

                               sipXpbx HA                  December 2005


   anything the caller would actually do with that information, so
   perhaps this should just return the value of DbUpdateNumber passed in
   the transaction (as an acknowledgment).

5.6.2.3.  registrySync.pullUpdates method

   This XML-RPC requests from a registrar all records it holds that are
   owned by the specified registrar whose update numbers are greater
   than the specified starting number.  The returned records are all the
   records that the server has with numbers greater than the starting
   number and less than or equal to the ending number.

   It is not yet decided whether the returned records will be only
   records with one update number (in which case all records have the
   same update number, the specified ending update number), or may
   encompass several update numbers.

   Alternatively, the call may return an indication that the server has
   no records owned by the specified registrar with higher update
   numbers.

   During startup, a registrar uses a series of Pull Update calls to
   download from the other registrars all DB records that it does not
   already have.

   If this XML-RPC fails, the client will mark the server as being
   "dead".

   Inputs:

        String  registrar_name      Owning registrar name
        int     update_number       This RPC contains all records with
                                    update numbers greater than update_number

   Outputs:
















Lawrence, et al.                                               [Page 14]

                               sipXpbx HA                  December 2005


        array   updates
          struct
            string  uri
            string  callid
            int     cseq
            string  contact
            int     expires
            string  qvalue
            string  instance_id
            string  gruu
            string  primary
            long long int update_number

        long long int  update_number        ending update number (for last update in array)

   When the server is responding to a Pull Updates message, it must only
   consider records whose update numbers are less than the Last Update
   Number Received for the registrar named in the request.  That's
   because the server is only authoritative for updates with update
   numbers less than LUNR, although its DB may contain records with
   update numbers higher than that due to receiving out-of-order Push
   Updates, etc.

   If the server responded with higher-number updates, it would update
   the client's LUNR for that Primary Registrar, and it would lose track
   of the fact it still needs to try to find lower-numbered records.

5.6.3.  RegisterTest -- Peer Reachability

   _The exact implementation of this processing has not yet been fixed.
   This discussion describes the approximate sequence and timing of the
   operations; the mechanism for achieving them may be revised._

   The RegisterTest thread is responsible for determining whether or not
   a previously unreachable peer has become reachable.  It is started
   initially by receipt of a PeerUnReachable OsMessage.  This causes it
   to start a timer _(duration to be determined)_; when the timer
   expires, it attempts the registrySync.Check method to test whether or
   not the peer can now be reached.

   On a successful return, the caller sets the PeerReachable value to
   "true", and the PeerSent DbUpdateNumber from the response.  The
   caller then sends a PushRegistryUpdate OsMessage to the RegistrySync
   thread to restart updates to the peer.

   Likewise, when this method is invoked, the server sets the
   PeerReceived DbUpdateNumber the arguments, and checks the
   PeerReachable value.  If PeerReachable is "false", it is reset to



Lawrence, et al.                                               [Page 15]

                               sipXpbx HA                  December 2005


   "true", and a PushRegistryUpdate OsMessage is sent to the
   RegistrySync thread to restart updates.

   On failure, the RegisterTest thread restarts the timer for the peer,
   using standard exponential backoff to a maximum interval of one
   eighth of the maximum registration interval.  This prevents useless
   and possibly harmful traffic being injected into the network in the
   event that the loss of connectivity is traffic related.

5.6.3.1.  registrySync.Check method

   Inputs:

     string         Name                          The sender's identifier
     long long int  PeerReceivedDbUpdateNumber    The current value of the sender's
                                                  PeerReceivedDbUpdateNumber.

   Outputs:

     long long int  PeerReceivedDbUpdateNumber    The current value of the recipient's
                                                  PeerReceivedDbUpdateNumber

   This XML-PRC is used by a client registrar during operation to
   inquire of the server registar whether it is operational, and to
   reset the peer's PeerSentDbUpdateNumber to match the client's input
   argument PeerReceivedDbUpdateNumber.  If this XML-RPC fails, the
   client will continue to consider the server as being "dead".  Also,
   if the server is in the first startup stage, it will return an
   indication, which the client will treat as failure.

   If the server is operational, it will mark the client as "live", set
   its PeerSentDbUpdateNumber for the client to the argument value, and
   queue a Push Updates for the client if there are updates to send.
   The server returns its PeerReceivedDbUpdateNumber for the client.

   If this XML-RPC succeeds, the client marks the server as "live", sets
   its Last Update Number Sent for the server to the return value, and
   queues a Push Updates for the server.

5.6.4.  Startup Processing

   When the registrar service starts, it attempts to read its own
   persistent registry store.  If successful, it restores all state
   variables from the store.  If not, then it:
      Initializes its local database DbUpdateNumber by setting the base
      time in the upper word from the current time and the counter in
      the lower word to zero.




Lawrence, et al.                                               [Page 16]

                               sipXpbx HA                  December 2005


      Sets the PeerSent DbUpdateNumber and PeerReceived DbUpdateNumber
      to zero.

   Because the PeerReceived DbUpdateNumber includes the peer's base
   time, a registrar service can detect when a peer has restarted and
   lost synchronization state.

   At startup, the server needs to discover quickly whether or not the
   local registry is the best available source of contact information.
   Before this is determined, the server does not open its redirector
   SIP port, so that clients will consider it to be down and fail over
   to another server.  A fairly elaborate process is needed to handle
   this situation well.

   Declare the peer registrar to be "live" (until proven otherwise).
   Make a Pull Updates request to the peer for records owned by the
   peer, starting from PeerReceived DbUpdateNumber.  If this registrar
   is restarting with no persistent state, then make a Pull Updates
   request to the peer for records owned by this registrar, starting
   from DbUpdateNumber = 0.  If either of these requests fails then mark
   the peer as "dead".

   At this point, the database contains all available registration
   records for either registrar.  To finish startup processing
      Set the operational live/dead indicators to "dead".
      Queue a Check operation for the peer registrars.
      Begin accepting Push Updates and Check XML-RPCs.
      Begin accepting REGISTERs and redirection requests.

   During startup, the Last Update Number for the registrar's database
   should be treated like the Last Update Number Received for a Primary
   Registrar, initialized from the recovered DB and incremented based on
   pulled data.  Especially if the local DB cannot be recovered, it
   should be initialized to 0/0.  Only once startup is done should it be
   set to a new epoch/0 value.  If the epoch/0 value is set initially,
   it will block pulling updates from other registrars.

   We might want to always initialize Last Update Number to epoch/0
   after startup, so we can always distinguish the various series of
   updates in the databases.

5.7.  XML-RPC Security

   Registry synchronization requests require that the RPC connection be
   SSL-authenticated as coming from a Server in the same SIP domain.

   * Initially, all synchronized Servers will use the same key and
   certificate. *



Lawrence, et al.                                               [Page 17]

                               sipXpbx HA                  December 2005


5.8.  HTTP Persistent Connections

   Because these updates will be quite frequent compared to any previous
   use of XML-RPC, and because they must be over SSL connections, we may
   need to modify our HTTP to support persistent connections.  We have a
   design for this based on how SIP TCP connections are done. _Whether
   or not this will be included in the 3.2 release depends on available
   time and the results of performance testing once synchronization is
   working._

5.9.  Authorization Proxy Record-Route

   Ideally, the authproxy Record-Routes should use the SRV record name
   as described in Section 3.  Using that mechanism, and assuming the
   phones support SRV record names in Record-Routes correctly, then in-
   dialog requests (like 'on/off hold') would fail over from one
   authproxy to another. *But phones that could not process an SRV name
   in a Record-Route would be unable to perform any in-dialog requests.*

   _At this time, the plan is to not change how the Record-Route is
   constructed (continue using the IP address rather than use the SRV
   name)._





























Lawrence, et al.                                               [Page 18]

                               sipXpbx HA                  December 2005


Authors' Addresses

   Scott Lawrence
   Pingtel Corp.

   Email: slawrence@pingtel.com


   Dale Worley
   Pingtel Corp.

   Email: dworley@pingtel.com


   Walter Gillett
   Pingtel Corp.

   Email: walter_gillett@hotmail.com

































Lawrence, et al.                                               [Page 19]

