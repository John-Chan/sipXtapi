Revisions to the sync design.


Database updates are labeled with 96-bit unsigned numbers.  The 96-bit
numbers are implemented as 3 32-bit unsigned numbers.  The middle- and
low-order numbers are a counter that is initialized to 0 and
incremented with each DB update.  The highest-order word is the Unix
time value when the lower two words were last initialized to 0.

This allows us to generate unique, monotonic update numbers even if
we've lost the history for a registry, since we can always
reinitialize the update number using the current time and be sure that
the update number is larger than any that has been used before by this
registrar.  The 64-bit counter is large enough for practical purposes
-- if we process 1,000 updates per second, the counter will wrap every
584,942,417 years.  (A 32-bit counter would wrap in 1.6 months.)

An update number is used to label the DB records that are modified by
that update, and can be used to designate a particular state of the
DB, namely, all record modifications with update numbers less than or
equal to the DB revision number.


Every registrar has a unique name, known by all registrars, which will
usually be its host name.  Every REGISTER is processed by the
registrar that first receives it, which is called the Primary
Registrar for the REGISTER, and the Primary Registrar is said to "own"
that registration and the records describing it (in every registrar
database).  Each Primary Registrar has a set of Replicated Registrars
that should contain duplicates of all registrations owned by that
Primary Registrar.  Each registrar knows all of the Replicated
Registrars for the registrations it owns, and also all of the Primary
Registrars for which it is a Replicated Registrar.

In addition, each registrar knows the list of its "sibling Replicated
Registrars", which includes the registrars listed above, and also the
registrars which are Replicated Registrars for a Primary Registrar for
which this registrar is a Replicated Registrar.


Processing is performed in two stages -- startup and operational.
During the startup stage, the registrar recovers its local database
(if possible), then pulls information from all of its sibling
registrars.  During the operational stage, the registrar processes
REGISTERs and pushes updates from siblings.

The central feature of this design is that during startup and
reconstruction of the database, the registrar pulls data, so that it
can tell when it has finished obtaining the data it desires.  But
during the operational phase, updates are pushed by the Primary
Registrar to ensure that they are propagated to the Replicated
Registrars quickly.

The only way a Replicated Registrar can trasition from being "dead" to
being "live" (in the eyes of its Primary Registrar) is through an
XML-RPC that communicates from the Replicated Registrar to the Primary
Registrar the update from which updates should commence being sent.


There are three XML-RPC calls.  The first is used during the startup
stage, and the second two are used during the operational phase:

Startup:  Pull Updates

Inputs:
	Owning registrar name
	Starting update number

Outputs:
	Record contents
	Ending update number

This XML-RPC requests from a registrar all records it holds that are
owned by the specified registrar whose update numbers are greater than
the specified starting number.  The returned records are all the
records that the server has with numbers greater than the starting
number and less than or equal to the ending number.

It is not yet decided whether the returned records will be only
records with one update number (in which case all records have the
same update number, the specified ending update number), or may
encompass several update numbers.

Alternatively, the call may return an indication that the server has
no records owned by the specified registrar with higher update
numbers.

During startup, a registrar uses a series of Pull Update calls to
download from the other registrars all DB records that it does not
already have.

If this XML-RPC fails, the client will mark the server as being
"dead".

Operation:  Push Updates

Inputs:
	Calling registrar name
	Starting update number
	Ending update number
	Record contents

Outputs:
	none

This XML-RPC is used by a registrar during operation to send one or
more updates that it owns to a Replicated Registrar.

If this XML-RPC fails, the client will mark the server as being
"dead".

Alternatively, if the server is in the first startup stage, it will
return an indication, and the client will also mark the server as
being "dead" to avoid sending further updates which cannot be
effectively processed during the first startup stage.

Similarly, it is not yet decided whether a Push Updates can contain
updates with more than one update number.

The server registrar will apply the updates to its database, and if
its Last Update Number Received is no less than the starting update
number, will set its Last Update Number Received to the ending update
number.

If the server registrar has the client registrar marked "dead", it
will mark it "live" and queue a Push Updates operation for it.

Operation:  Check

Inputs:
	Calling registrar name
	Client Last Update Number Received

Outputs:
	Server Last Update Number Received

This XML-PRC is used by a registrar during operation to inquire of the
server whether it is operational, and to reset its Last Update Number
Sent.  If this XML-RPC fails, the client will continue to consider the
server as being "dead".  Also, if the server is in the first startup
stage, it will return an indication, which the client will treat as
failure.

The server is operational, it will mark the client as "live", set its
Last Update Number Sent for the client to the argument value, and
queue a Push Updates for the client.  The client returns its Last
Received Update Number for the client.

If this XML-RPC succeeds, the client marks the server as "live", sets
its Last Update Number Sent for the server to the return value, and
queues a Push Updates for the server.


A registrar keeps the following persistent (across reboot) state:

- Last Database Update Number

This monotonically labels all database updates that this registrar
owns.

- For each registrar for which this one is a Replicated Registrar:

  - Last Update Number Received

This registrar's database contains all updates owned by that registrar
whose update numbers are no greater than the Last Update Number
Received.

A registrar keeps the following operational state (persistent across
transactions but not across reboots):

- For each Replicated Registrar, a live/dead indicator.

- For each registrar which is a Replicated Registrar for this one:

  - Last Update Number Sent

This registrar has successfully sent to the Replicated Registrar all
updates that this registrar owns whose update numbers are no greater
than the Last Update Number Sent.


* Startup stage

- Recover persistent store.

Recover the database contents.  If it cannot be recorvered, initialize
it as empty.

Recover the Last Database Update Number.  If it cannot be recovered,
construct a new value by using the current time as the high-order
word, with a count of 0/0.

Initialize the Last Update Numbers Sent to 0/0/0.

Recover the Last Update Numbers Received.  If they cannot be recovered,
initialize to 0/0/0.

- Pull all missing updates.

Initialize a set of live/dead indicators for every sibling registrar
to "live".

Update the data for ourself and every registrar "D" for which we are a
Replicated Registrar:

    Query every sibling registrar "R":

	If R is marked "live", make a Pull Updates request to R for records
	owned by D, starting from the Last Update Number Received.

	If records were retrieved, apply them to the database, update the Last
	Update Number Received, and return to the previous step.

	If no further records could be retrieved, continue to the next sibling
	registrar R.

	If the XML-RPC failed, mark R as "dead", continue to the next
	registrar D.

At this point, the database contains all available records for which
this registrar is a Primary or Replicated Registrar.

- Set the operational live/dead indicators to "dead".

- Queue a Check operation for all Replicated Registrars.

- Begin accepting Push Updates and Check XML-RPCs.

- Begin accepting REGISTERs and redirection requests.

* Operational stage

- REGISTER processing

When a REGISTER is processed, convert it to a set of database updates
and enter them in the database as owned by this registrar.  Increment
the Last Database Update Number and apply that to the updated records.
Queue a request to push updates.

- Push update processing

For each Replicated Registrar R:

    If R is marked "live", send it a Push Updates XML-RPC containing all
    updates from the Last Update Number Sent for R to the Last Database Update
    Number (or an initial subset thereof).

	R will update its database using the records.  If its Last
	Update Number Received is greater than or equal to the
	starting number in the XML-RPC, it will set its Last Update
	Number Received to the ending number.  If its Last Update
	Number Received is less than the starting number, it will
	queue a Check operation for the client.

        If R has the client marked "dead", it will queue a Check
        operation for it.

    If the XML-RPC succeeds, update the Last Update Number Sent for R to
    the ending number in the XML-RPC.

    If the XML-RPC fails, mark R as "dead" and queue Check processing
    for R.

- Check processing

This is done periodically for every Replicated Registrar while it is
marked "dead".

Send a Check XML-RPC.

    The server will mark the client "live", set its Last Update Number
    Sent from the argument, and queue a Push Updates for the client.

If the XML-RPC succeeds, mark the registrar "live", set its Last
Update Number Sent from the return value, and queue a Push Updates for
the server.

If the XML-RPC fails, mark the registrar "dead" and queue Check
processing for a later time.
