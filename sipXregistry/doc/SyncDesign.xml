<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC ""
      "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<?rfc private="SIPfoundry sipXpbx" ?>
<?rfc toc="yes" ?>
<?rfc tocdepth="4" ?>
<?rfc topblock="no" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="yes" ?>
<?rfc compact="yes" ?>
<!--<?rfc strict="yes" ?>-->

<rfc category="std" ipr="none" docName="sync-design">
  <front>
    <title abbrev="sipXpbx HA">sipXpbx High Availability</title>
    <author initials="S." surname="Lawrence" fullname="Scott Lawrence">
    <organization>Pingtel Corp.</organization>
    <address>
      <email>slawrence@pingtel.com</email>
    </address>
    </author>
    <author initials="D." surname="Worley" fullname="Dale Worley">
    <organization>Pingtel Corp.</organization>
    <address>
      <email>dworley@pingtel.com</email>
    </address>
    </author>
    <date day="23" month="November" year="2005"/>
    <area>sipXregistry</area>

  </front>

  <middle>

    <section title="Motivation and Overview">
      <t>
        In large systems, high availability (HA) is essential; a PBX with
        more than a few dozen users generally must not have any unexpected
        outages for basic calling.  It does seem to be true that voice mail
        and perhaps some other services do not have the same availability
        requirement.  In sipXpbx, basic calling depends on three
        components: the two proxies and the registrar/redirect service.  The
        proxies can be replicated and DNS SRV records can be used to
        share load and
        provide for failover.  The registrar/redirect service, however,
        cannot currently be deployed on multiple servers because the
        'soft'
        state in the registry database (mappings from registered Addresses
        to Contacts) cannot be shared.  While replicating the proxies alone
        does help with scaling, the registrar is a single point of failure
        for basic calling service.
      </t>
      <t>
        This memo describes a system architecture to provide high
        availability service for basic calling, by adding the
        required replication of registration information
      </t>
      <t>
        <spanx style='strong'>
          In order to make the basic HA capability available as quickly as
          possible, the plan is to implement those features that are
          absolutely required, but not support an automated installation.
          Some custom, manual configuration will be required. Release 3.2
          will support only 2 registrars.
        </spanx>
      </t>

    </section>

    <section title="Terminology">
      <list style='hanging'>
        <t hangText='Server'>
          A physical computer system.
        </t>
        <t hangText='Service'>
          A process or processes running on a Server that performs a
          particular function.
        </t>
        <t hangText='Primary Registrar'>
          For a particular REGISTER request, the registrar that receives it
          and performs initial processing for it.
          Note that the Primary Registrar may not be the
          same for successive REGISTER requests, even from one UA.
        </t>
        <t hangText='Replicated Registrar'>
          For a particular REGISTER request,
          any registrar other than its Primary Registrar to which 
          its information is replicated.
        </t>
      </list>
    </section>

    <section title='High Availability Architecture' anchor='arch'>
      
      <t>
        In an HA configuration, there are at least two types of Server:
      </t>
      <list style='bullet'>
        <t>one Master Server running:</t>
        <list style='bullet'>
          <t>sipXconfig service</t>
          <t>optionally, also the set of the processes of a
             Distributed Server</t>
        </list>
        <t>one or more Distributed Servers, each running:</t>
        <list style='bullet'>
          <t>one forking proxy</t>
          <t>one authentication proxy</t>
          <t>one registrar/redirect service</t>
        </list>
      </list>
      <t>
        Other PBX Services may be distributed among the above Servers,
        or run on other Servers:
      </t>
      <list style='bullet'>
        <t>sipXvxml service with applications</t>
        <t>sipXpublisher (status server)</t>
        <t>sipXpresence</t>
        <t>sipXacd</t>
      </list>
      
      <t>
        <spanx style='strong'>
          In Release 3.2, only one configuration will be supported: one
          Distributed Server running only the proxies and registrar/redirect
          service, and one Master Server running all Services.
        </spanx>
      </t>

      <t>
        In order to provide load sharing and failover, all SIP message
        routing to any redundant element in an HA configuration uses DNS
        SRV records.  The following SRV records are required:
      </t>

      <list style='hanging'>
        <t hangText='domain'>
          In a single-system installation, an SRV record that maps the SIP
          domain name to the Server host name is recommended.  In an HA
          installation, multiple SRV records for the SIP domain name are
          required, mapping to the Server names/ports that run the forking proxy
          service.  There are domain SRV records specifying both TCP and
          UDP (with TCP given preference).  For example:
        </t>
       <figure>
         <artwork>
      $ORIGIN example.com.

      _sip._tcp IN SRV   1 50 5060 sipxpbx1
      _sip._tcp IN SRV   1 50 5060 sipxpbx2

      _sip._udp IN SRV 101 50 5060 sipxpbx1
      _sip._udp IN SRV 101 50 5060 sipxpbx2
         </artwork>
       </figure>

        <t hangText='registrar'>
          The <spanx style='verb'>forwardingrules.xml</spanx> for each
          forking proxy service specifies the registrar using an SRV name
          that maps first to the registrar instance on the same Server as
          the proxy (which is quicker to reach and more likely to be
          operational), and then to the registrar instance on the other
          Server (for failover).
          
          The registrar
          service SRV records specify only TCP, because TCP has better
          failure detection and performance characteristics and
          compatibility with User Agents is not required.  
        </t>
       <figure>
         <artwork>
     _sip._tcp.sipxregistrar1 IN SRV 1 50 5070 sipxpbx1
     _sip._tcp.sipxregistrar1 IN SRV 2 50 5070 sipxpbx2

     _sip._tcp.sipxregistrar2 IN SRV 1 50 5070 sipxpbx2
     _sip._tcp.sipxregistrar2 IN SRV 2 50 5070 sipxpbx1
         </artwork>
       </figure>
       <t>
         In the example above, the forking proxy on
         <spanx style='verb'>sipxpbx1</spanx> would
         be configured to use <spanx
         style='verb'>sipxregistrar1</spanx>, which
         preferentially routes to <spanx style='verb'>sipxpbx1:5070</spanx>
         and fails over to
         <spanx style='verb'>sipxpbx2:5070</spanx>.
         The forking proxy on <spanx style='verb'>sipxpbx2</spanx> is
         configured to use
         <spanx style='verb'>sipxregistrar2</spanx>,
         which uses the two Services in the reverse order.
       </t>

       <t hangText='authproxy'>
          The <spanx style='verb'>forwardingrules.xml</spanx> for each
          forking proxy service specifies the authorization proxy
          using a specialized SRV name configured similarly to the SRV
          name for the registrar.
          The
          authorization proxy SRV records specify both TCP and UDP,
          preferring TCP, but allowing UDP for compatibility with User
          Agents that require it.  (The authorization proxy may be
          Record-Routed in dialogs.)
        </t>
       <figure>
         <artwork>
      _sip._tcp.sipxauthproxy1 IN SRV   1 50 5080 sipxpbx1
      _sip._tcp.sipxauthproxy1 IN SRV   2 50 5080 sipxpbx2
      _sip._udp.sipxauthproxy1 IN SRV 101 50 5080 sipxpbx1
      _sip._udp.sipxauthproxy1 IN SRV 102 50 5080 sipxpbx2

      _sip._tcp.sipxauthproxy2 IN SRV   1 50 5080 sipxpbx2
      _sip._tcp.sipxauthproxy2 IN SRV   2 50 5080 sipxpbx1
      _sip._udp.sipxauthproxy2 IN SRV 101 50 5080 sipxpbx2
      _sip._udp.sipxauthproxy2 IN SRV 102 50 5080 sipxpbx1
         </artwork>
       </figure>
       <t>
         The selection technique used to create a preference order for
         registrars is also used for the authproxy, except that SRV
         records for UDP access are also provided, at lower priority
         than all the SRV records for TCP access.
       </t>

       <t>
         <spanx style='strong'>
           Currently, when the authproxy Record-Routes itself, it
           specifies its IP address in the Record-Route header.
           The authproxy could insert a Record-Route that specifies its SRV
           name (as detailed above); doing so would allow
           the processing of in-dialog requests to fail over 
           from one instance to another.
           Whether or not the authproxy should do this depends on
           whether or not user agents support DNS names in Route
           headers.
           Testing is required to determine the best method for Record-Routing.
         </spanx>
       </t>
      </list>
    </section>

    <section title='Current Registrar/Redirect Database Management'>

      <t>
        This section describes the operation of the registrar in
        sipXpbx version 3.0; it does not
        include description of the HA changes, or the changes for GRUU
        support..
      </t>

      <section title='Registry Updates'>

        <t>
          The updating of the registry is handled by the routine
          SipRegistrarServer::applyRegisterToDirectory and the sibdb
          RegistrationDB class.  The applyRegisterToDirectory method is called
          after the REGISTER request has been authenticated; it validates the
          registration by checking to see if the Call-ID and CSeq are in
          sequence by calling RegistrationDB::isOutOfSequence.
        </t>

        <t>
          applyRegisterToDirectory then parses and validates the contacts
          and expiration time in the
          request and converts them to an internal list.
        </t>

        <t>
          If the request is valid, there are two cases: expiring all
          contacts, and updating contacts.
        </t>
        <list style='hanging'>

          <t hangText='Expiring All Contacts' anchor='expall'>
            If the REGISTER request had an
            '<spanx style='verb'>Expire:&nbsp;0</spanx>' header and 
            just a '<spanx style='verb'>Contact:&nbsp;*</spanx>' header
            then it is requesting that all contacts for this Address
            Of Record (not just those from this
            Call-ID) be expired.  This is done using a single call to:
          </t>
          <figure>
            <artwork>
       RegistrationDB::expireAllBindings( aor, callid, cseq, timeNow )
            </artwork>
          </figure>
          <t>
            The last three arguments to expireAllBindings are not used
            to select which bindings to operate on.  (All bindings for
            the given AOR are expired.)  Rather, they are used for
            marking the bindings as expired -- Bindings are expired by
            setting their expiration time to "timeNow minus 1 second", and
            setting their "last updated by" information to the Call-ID
            and CSeq specified.
          </t>

          <t hangText='Updating Contacts' anchor='upCont'>
            The other case is when there are real contacts in the
            set.  All contacts which are listed are
            to have their expiration times updated, and all other
            contacts which have last been updated with by REGISTERs
            with this Call-ID are to be expired.
          </t>
          <t>
            The listed contacts are updated by calling
            RegistrationDB::updateBinding on each contact:
          </t>
          <figure>
            <artwork>
      RegistrationDB::updateBinding( toUrl, 
                                     contact,     
                                     qvalue,
                                     registerCallidStr, 
                                     registerCseqInt,
                                     expirationTime 
                                     )
            </artwork>
          </figure>
          <t>
            Each contact has its q-value and expiration time set, and the
            Call-ID and CSeq are recorded as its "last updated by" information.
          </t>
          <t>
            After all the contacts in the REGISTER message have been updated,
            any contacts that have the same Call-ID but an earlier CSeq
            number are expired by a single call to:
          </t>
          <figure>
            <artwork>
              RegistrationDB::expireOldBindings( toUrl, 
                                                 registerCallidStr,
                                                 registerCseqInt, 
                                                 timeNow
                                                 )
            </artwork>
          </figure>
        </list>
      </section>

      <section title='Locking'>
        <t>
          Other than the locks internal to FastDB, there are no locks on
          any of the above operations.  This works because only the single
          SipRegistrarServer thread ever writes to the registry database.
        </t>
      </section>
    </section>

    <section title='Changes'>

      <t>
        The following sections detail the changes needed to implement the
        replicated registrar architecture.
      </t>

    <section title='Configuration'>
      <t>
        An HA Registrar has two additional configuration parameters:
      </t>
      <list style='hanging'>
        <t hangText='SIP_REGISTRAR_SYNC_WITH'>
          The host name of the other registrar to sync to.  (<spanx
          style='emph'>In future versions, this may allow a comma-separated
          list of Servers.</spanx>)
        </t>
        <t hangText='SIP_REGISTRAR_XMLRPC_PORT'>
          The port number used by all Servers to listen for XML-RPC registry
          synchronization requests. 
        </t>
      </list>

      <t>
        <spanx style='emph'>The set of configuration parameters may be
        changed in future versions of the HA system.  Compatibility
        is only guaranteed with those sipXconfig versions which support
        HA.</spanx>
      </t>

    </section>

    <section title='Registry Synchronization State'>
      <t>
	The Registrar Service maintains persistent (across start-ups)
	state for synchronization purposes:
      </t>
      <list style='hanging'>

	<t hangText='DbUpdateNumber'>
	  A circular counter of update operations to its own
	  registry database.  DbUpdateNumber is updated only for
	  registrations for which this registrar is the Primary Registrar.
	</t>
	<t hangText='SyncronizationBaseTime'>
	  The SynchronizationBaseTime is the epoch time at which the
	  registrar last started with no prior registration state.
	</t>

      </list>

      <t>
	Together, a value of DbUpdateNumber and the corresponding
	SynchronizationBaseTime and are referred to as a
	"succession".  The above two values are called the
	"local DB succession".
      </t>

      <t>
	The "base time" component of a succession is is a Unix time
	value, the number of seconds since 00:00 GMT, 1 January
	1970.  It is the time at which the Service last initialized its
	update number.  Since all Servers are expected to have
	reliable, NTP-synchronized clocks, base times created by a
	Service always increase.  Since initializations of the
	update number are expected to be rare, all base times in a
	system are unique.
      </t>

      <t>
	  Since
	  registration state is preserved across restarts, this base
	  time of the local DB succession will
	  usually not be the same as the start time of the current
	  registrar instance.
      </t>

      <t>
	The "update number" component of a succession is an
	unsigned, 32-bit integer.  It is incremented circularly, in
	that the successor of 4,294,967,295 (2^32-1) is 0.
	Since DB records must be updated frequently (at least on the
	order of once every 24 hours) or they will be purged, the update
	numbers attached to DB records at any one moment must be in
	a narrow range (typically less than 100,000,000).  Thus, two
	update numbers that appear simultaneously in processing can
	be unambiguously compared for "less than" and "greater
	than" by examining them within the narrow range that they
	must share.  This comparison can be carried out directly by
	FastDB by taking the unsigned difference of the update
	numbers and then comparing the difference with 2,147,483,648
	(2^31).
      </t>

      <t>
	Two successions are compared for "less than" and "greater
	than" by first comparing their base times, and if the base
	times are equal, then comparing their update numbers as
	described above.  This comparison can also be carried out
	by FastDB using an appropriate expression directly.
      </t>

      <list style='hanging'>

	<t hangText='PeerReceivedDbUpdateNumber'>
	</t>
	<t hangText='PeerReceivedSyncronizationBaseTime'>
	  The peer's DB succession of the last update that was
	  received from the peer.
	</t>
	<t hangText='PeerSentDbUpdateNumber'>
	</t>
	<t hangText='PeerSentSyncronizationBaseTime'>
	  The local DB succession of the last update that was sent
	  to the peer.
	</t>

      </list>

      <t>
	The registrar service maintains additional state that is not
	persistent:
      </t>

      <list style='hanging'>
	<t hangText='PeerReachable'>
	  This is a boolean that indicates whether or not the peer
	  is believed to be reachable.
	  It is initialized on startup to <spanx style='verb'>false</spanx>, indicating that the peer is
	  not known to be reachable.  It is set to <spanx style='verb'>false</spanx> by most operations
	  if they fail to reach the peer, and is set to <spanx style='verb'>true</spanx>
	  the RegisterTest
	  thread (see <xref target='regtest'/>) when it discovers that it
	  can reach the peer.  When it is <spanx style='verb'>false</spanx>, most operations do not
	  attempt to contact the peer.
	</t>
      </list>

    </section>

    <section title='Registration Database'>

      <section title='Additional DB Columns' anchor='dbcolumns'>

	<t>
	  Each row in the registration database (which corresponds to a
	  binding of a contact URI to an AOR) gains two columns:
	</t>
	  <list style='hanging'>

	    <t hangText='Primary'>
              A string which is the identifier of Primary Registrar
	      for this binding.  This identifier is selected by the
	      Primary Registrar, and  will usually be the host name of
	      its Server, but the only requirement is that each
	      registrar has a distinct identifier.
	    </t>
	    <t hangText='DbUpdateNumber'>
            </t>
	    <t hangText='BaseTime'>
              The succession (of the Primary Registrar's DB) of the update
	      which inserted or last modified this row.
	    </t>

	  </list>

      </section>

      <section title='Overall DB Structure'>

        <t>
          The entries in the registration database maintain the state for
          registrations of contacts for Addresses Of Record.
          Entries are indexed by AOR, contact, and the Call-ID of the sequence
	  of REGISTERs (the registration quasi-dialog) that establish
          and maintain
          the registration.
        </t>

        <t>
          Entries are considered to have expired when the current
          time exceeds the expiration time
          recorded in the entry.  The entry is not removed at that time, 
          so that the entry can maintain the "last CSeq seen" value for that
          Call-ID, in case an out-of-sequence REGISTER arrives.
          Entries are removed from the DB after one hour after they expire,
          as we assume that is long enough that out-of-order REGISTERS
          will no longer be in transit.
        </t>

        <t>
          When a registration is to be expired
          in advance of its previously scheduled expiration time (due
          to the processing of some REGISTER message),
          its DB entry is modified by reducing its expiration time to one 
          second before the current time.
        </t>

        <t>
          Each entry contains the following fields.  (The fields for
          GRUU support are not listed, but they do not affect any of
          the replication algorithms.)
        </t>

        <list style='hanging'>
          <t hangText='uri'>
            The AOR of this registration.
          </t>
          <t hangText='contact'>
            The contact of this registration.
          </t>
          <t hangText='qvalue'>
            The q-value of this registration.
          </t>
          <t hangText='callid'>
            The Call-ID of the REGISTERs that establish/maintain this
            registration.
          </t>
          <t hangText='cseq'>
            The largest CSeq seen for REGISTERs for this registration.
          </t>
          <t hangText='instanceid'>
            The <spanx style='verb'>+sip.instance</spanx> value that
            was provided with the registration, or the null string.
          </t>
          <t hangText='gruu'>
            The GRUU that was assigned to this registration, or the
            null string.
          </t>
          <t hangText='primary'>
            The name of the Primary Registrar for this registration.
          </t>
          <t hangText='update'>
          </t>
          <t hangText='basetime'>
            The succession of the last modification of this entry.
          </t>
        </list>

      </section>

    </section>

    <section title='Thread Structure and Locking'>

      <t>
	There are three threads in each registrar:
      </t>

      <list style='hanging'>
	<t hangText='RegisterServer'>
	  This thread processes incoming REGISTER messages, applying
	  the necessary updates to the DB, and notifying
	  RegisterSync thread that when it needs to propagate
	  updates.
	</t>
	<t hangText='RegisterSync'>
	  This thread is the XML-RPC client that sends updates to
	  the peer server.
	</t>
	<t hangText='RegisterTest'>
	  This thread is the XML-RPC client that tests, when the
	  peer Service is thought to be down or unreachable, whether
	  it is now reachable.
	</t>
	<t hangText='HttpServer'>
	  This thread is the XML-RPC server.
	  It must be a separate from the XML-RPC client to avoid multi-Server
	  XML-RPC deadlock chains.
	</t>
      </list>

    <t>
      Registry database updates are protected by an OsMutex; it is taken
      by applyRegisterToDirectory and by each of the registrySync XML-RPC
      server methods.  This serializes all the checks for CSeq correctness, and
      also protects the synchronization state variables.
    </t>
    <t>
      The XML-RPC client threads (RegisterSync and RegisterTest) will also
      hold the lock when they are modifying the synchronization state,
      but never while they are making XML-RPC calls, in order to avoid
      mult-Server deadlocks.
    </t>
    <t>
      <spanx style='emph'>
	There is no locking between updates to the registry database and
	reads from it by the redirect service; the FastDB ensures
	sufficient integrity that none is needed.
      </spanx>
    </t>

    </section>

    <section title='Processing' anchor='xmlrpcsync'>

      <t>
        Registrar processing is done by a number of interlocking
        operations which are detailed below.
        Synchronization between registrars is done using XML-RPC (see <xref
        target='xmlrpcsync'/>).  The XML-RPC URI for these operations
        always has scheme <spanx style='verb'>https</spanx>
        (see <xref target='xmlrpcsec'/>), the host name specified by
        the SIP_REGISTRAR_SYNC_WITH configuration item,
        and the fixed path <spanx style='verb'>/RPC2</spanx>.
      </t>

      <section title='RegisterServer -- Register Message Processing'
        anchor='regproc'>

        <t>
          When a REGISTER message has been determined to be valid, the local
          DB update number is incremented, and the changes are applied
          to the local
          registry database. The local DB succession value is recorded in
          each updated row in the registry database.  The SipRegistrarServer
          thread then sends a PushRegistryUpdate OsMessage to the
          RegisterSync thread to trigger replication to the peer registrar.
        </t>

        <t>
          In all cases, the Primary Registrar first reduces the effect of
          the REGISTER to the insertion/modification of a number of entries
          in the DB.  The entries are then tagged with the
          Call-ID/CSeq of the REGISTER request, and the local DB succession
          of the new version of the DB.  It is
          these records that are then propagated to the Replicated
          Registrar.
        </t>

        <t>
          This transformation of the REGISTER before propagation is
          not absolutely correct according to RFC 3261, as it does not
          process "expire all" operations correctly in certain uncommon race
          situations, but it ensures that the results of replication
          are accurately defined (since the processing of the DB updates
          will produce the same result regardless of the order in
          which they are processed).
          Even in cases where the RFC 3261 result is not produced, the
          result is always the same as
          would be produced by the same messages if they were received with
          certain small changes in their arrival times.
        </t>
        
      </section>

      <section title='RegisterSync -- Sending Updates to the Peer Server'>

        <t>
          The RegisterSync thread is responsible for propagating updates to
          the peer registrar. <spanx style='emph'>(When multiple peers are
          supported, there may be one thread per peer or just one for all
          peers -- this is a subject for future study.)</spanx>
        </t>

        <t>
          When the RegisterSync thread receives a PushRegistryUpdate message,
          it checks the peer state:  If PeerReachable is
          <spanx style='verb'>true</spanx>, and if the local DB succession
          is greater than the PeerSent succession, then
          registerSync.updateContacts XML-RPC method is used to propagate all
          updates that have not been sent to the peer (one invocation per
          unsent transaction).  After a successful return of the XML-RPC,
          the PeerSent succession is updated.
        </t>
        
        <section title='Detailed Operation'>

          <t>
            registrySync.updateContacts is used by one Registrar to
            push updates to
            its peer registrar.  It is initiated by the RegisterSync
            thread when it is notified that there are (may be) updates
            in the local DB for which it is the Primary Registrar and
            which have not been propagated to the peer registrar.
          </t>

          <t>
            First, RegisterSync checks the peer state:  If PeerReachable is
	    <spanx style='verb'>false</spanx>, it immediately
	    terminates processing the PushRegistryUpdate message.
            (The updates that need to be sent will be sent when
	    RegisterTest detects that the peer registry is reachable.)
          </t>

          <t>
            Next, the RegisterSync thread checks that the local DB
            succession is greater than the PeerSent succession.  If
            not, there are no updates to propagate, and the thread
            terminates processing the message.
          </t>

          <t>
            If there are updates to propagate, the RegisterSync thread
            extracts all records in the local DB that were updated by
            this registrar as the Primary Register, and whose
            successions are greater than the PeerSent succession.
            These records are packaged into one or more
            registrySync.updateContacts XML-RPC calls which are sent
            in succession to the peer registrar.
          </t>

          <t>
            The XML-RPC server of the peer registrar -- which must be
            the Replicated
            Registrar for thse updates -- first validates that the
            succession in the XML-RPC is greater than its PeerReceived
            succession.  If not, this XML-RPC is a duplicate of one
            received previously, and the call can be returned
            successfully without any further work.
          </t>

          <t>
	    The server then applies the updates to its
            DB in the standard manner.  That is, it validates that the
            local database does
            not have more recent information (using the Call-ID and
            CSeq values)
            and if not, applies each update to its own database.
            These updates do not increment the local DB update number
            (since they do not need to be identified), and
            there is no need
            to trigger this registrar's RegisterSync thread to
            propagate the updates further.
          </t>

          <t>
            The server then updates its PeerReceived succession and returns
            the request successfully.
          </t>

          <t>
            The server also
            checks its PeerReachable status for the client; if it is <spanx
            style='verb'>false</spanx>, then the server
            knows that the peer is no reachable again, and so it 
            sets its PeerReachable status for the client to
            <spanx style='verb'>true</spanx> and sends a
            PushRegistryUpdate OsMessage to its RegistrySync thread.
          </t>

          <t>
            When the XML-RPC returns, the client updates its PeerSent
            succession, and continues with the next set of updates to
            be sent, or finishes with the PushRegistryUpdate message.
            This allows the registrar to know reliably what has been
            pushed to the peer, since a lost response will cause the
            update to be re-sent.
          </t>

          <t>
            On any registrySync.updateContacts failure, the client sets its
            PeerReachable value
            to <spanx style='verb'>false</spanx>, and sends a PeerUnReachable
            OsMessage to the RegisterTest thread.
          </t>

        </section>

        <section title='registrySync.updateContacts'>

          <t>Inputs:</t>
          <figure>
            <artwork>
     int     updatenumber        This RPC contains all record with
                                 update numbers greater than the PeerSent
                                 of the client and less than or equal
                                 to the 'updatenumber' field.
     array   updates
       struct
         string  uri
         string  callid
         int     cseq
         string  contact 
         int     expires
         string  qvalue
         string  instance_id
         string  gruu
            </artwork>
          </figure>

          <t>Outputs:</t>
          <figure>
            <artwork>
           struct
     int  SynchronizationBaseTime  
     int  DbUpdateNumber           the current succession of the server's DB
            </artwork>
          </figure>

          <t>
            TBD -- The intent of return values was to inform the
            caller that there were unpropagated updates, but I'm not sure that
            there is anything the caller would actually do with that
            information, so perhaps this should just return the value of
            DbUpdateNumber passed in the transaction (as an
            acknowledgment).
          </t>

      </section>

      </section>

      <section title='RegisterTest -- Peer Reachability' anchor='regtest'>

        <t>
          <spanx style='emph'>The exact implementation of this
          processing has not yet been fixed.  This discussion
          describes the approximate sequence and timing of the operations; the
          mechanism for achieving them may be revised.</spanx>
        </t>

        <t>
          The RegisterTest thread is responsible for determining whether or
          not a previously unreachable peer has become reachable.  It is
          started initially by receipt of a PeerUnReachable OsMessage.
          This causes it to start a timer <spanx style='emph'>(duration to
          be determined)</spanx>; when the timer expires, it attempts
          the registrySync.Check method to test whether or not the
          peer can now be reached.
        </t>

	<t>
	  On a successful return, the caller sets the
          PeerReachable value to <spanx style='verb'>true</spanx>, and
          the PeerSent succession from the
	  response.  The caller then sends a PushRegistryUpdate
	  OsMessage to the RegistrySync thread to restart updates to the
	  peer.
	</t>

	<t>
	  Likewise, when this method is invoked, the server sets the
	  PeerReceived succession 
	  the arguments, and checks the PeerReachable value.  If
	  PeerReachable is
	  <spanx style='verb'>false</spanx>, it is reset to <spanx
	  style='verb'>true</spanx>, and a PushRegistryUpdate
	  OsMessage is sent to the RegistrySync thread to restart updates.
	</t>

	<t>
	  On failure, the RegisterTest thread restarts the timer for the
	  peer, using standard exponential backoff to a maximum interval
	  of one eighth of the maximum registration interval.  This
	  prevents useless and possibly harmful traffic being injected
	  into the network in the event that the loss of connectivity is
	  traffic related.
	</t>

        <section title='registrySync.Check'>

          <t>Inputs:</t>
          <figure>
            <artwork>
  string  Name                     The sender's identifier
     int  SynchronizationBaseTime  The time when the sender last
                                   initialized its synchronization data
     int  DbUpdateNumber           The current value of the senders 
                                   update counter.
            </artwork>
          </figure>

          <t>Outputs:</t>
          <figure>
            <artwork>
   struct
     int  SynchronizationBaseTime  the time when the recipient last
                                   initialized its synchronization data
     int  DbUpdateNumber           the current value of the recipients 
                                   update counter.
            </artwork>
          </figure>

        </section>
      </section>

      </section>

      <section title='Startup Processing' anchor='startup'>

	<t>
	  When the registrar service starts, it attempts to read its
	  own persistent
	  registry store.  If there is no persistent registry store,
	  it initializes its local database SynchronizationBaseTime
	  from the current time and sets its the local database
	  DbUpdateNumber to 0.  Otherwise, SynchrionizationBaseTime
	  and DbUpodateNumber are set from the persistent store.
          (The SynchronizationBaseTime value
	  is always passed with the DbUpdateNumber, and the
	  SynchronizationBaseTime value from each peer is also recorded.
	  This allows each registrar service to detect when a peer has
	  restarted and lost synchronization state.)
	</t>

        <t>
          The PeerSent succession is initialized to the local DB
          succession, since the local DB is empty.
          The PeerReceived succession is initialized to base time 0
          and update number 0.  When registrySync.Check transmits this
          value to the peer, it will send its entire database contents
          to this registrar.
	</t>

        <t>
          At startup, the server needs to discover quickly whether or not the
          local registry is the best available source of contact
          information.  Before this is determined, the server does not open
          its redirector SIP port, so that clients will consider it to be down and
          fail over to another server.  A fairly elaborate process is
          needed to handle this situation well.
        </t>

        <t>
          In order to discover whether the local registry is the best
          available, the registrar makes a registrySync.Check request
          to the peer. 
        </t>
        <list style='bullet'>
          <t>
            If this request fails, then there is no known
            better source of contact data, so it opens the SIP port.
            As always with an XML-RPC failure, it also sets
            the PeerReachable state is set to <spanx
            style='verb'>false</spanx>, and sends a PeerUnReachable
            OsMessage to the RegisterTest thread.
          </t>
          <t>
            If this request succeeds, then it sets PeerReachable to <spanx
            style='verb'>true</spanx> and compares the remote synchronization state
            to the peer synchronization data.
          </t>
          <list style='bullet'>
            <t>
              If the remote synchronization values
              indicate that all updates from the peer have been received,
              then it opens the SIP port.
            </t>
            <t>
              If the remote synchronization values
              indicate that the registries are not synchronized, then a
              PushRegistryUpdate message is sent to the RegistrySync thread
              to push any updates to the peer, and the startup process
              waits for the peer to
              push its updates it has before opening the local SIP port.
            </t>
          </list>
        </list>
      </section>

    <section title='XML-RPC Security' anchor='xmlrpcsec'>
      <t>
        Registry synchronization requests require that the RPC connection be
        SSL-authenticated as coming from a Server in the same SIP domain.
      </t>
      <t>
        <spanx style='strong'>
          Initially, all synchronized Servers will use the same key and certificate.
        </spanx>
      </t>

    </section>

    <section title='HTTP Persistent Connections'>

      <t>
        Because these updates will be quite frequent compared to any
        previous use of XML-RPC, and because they must be over SSL
        connections, we may need to modify our HTTP to support persistent
        connections.  We have a design for this based on how SIP TCP
        connections are done.  <spanx style='emph'>Whether or not this will
        be included in the 3.2 release depends on available time and the
        results of performance testing once synchronization is
        working.</spanx>
      </t>

    </section>

    <section title='Authorization Proxy Record-Route' anchor='authrrsv'>
      <t>
        Ideally, the authproxy Record-Routes should use the SRV record
        name as
        described in <xref target='arch'/>.  Using that mechanism, and
        assuming the  phones support SRV record names in Record-Routes
        correctly, then in-dialog requests (like 'on/off hold')
        would fail over from one authproxy to another.  <spanx
        style='strong'>But phones that could not process an SRV name in a
        Record-Route would be unable to perform any in-dialog
        requests.</spanx> 
      </t>
      <t>
        <spanx style='emph'>At this time, the plan is to not change how
        the Record-Route is constructed (continue using the IP address rather
        than use the SRV name).</spanx>
      </t>
    </section>

  </section>

</middle>
<back>
</back>

</rfc>
