<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC ""
      "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>

<?rfc private="SIPfoundry sipXpbx" ?>
<?rfc toc="yes" ?>
<?rfc tocdepth="4" ?>
<?rfc topblock="no" ?>
<?rfc symrefs="yes" ?>
<?rfc sortrefs="yes"?>
<?rfc iprnotified="yes" ?>
<?rfc compact="yes" ?>
<!--<?rfc strict="yes" ?>-->

<rfc category="std" ipr="none" docName="sync-design">
  <front>
    <title abbrev="sipXpbx HA">sipXpbx High Availability</title>
    <author initials="S." surname="Lawrence" fullname="Scott Lawrence">
    <organization>Pingtel Corp.</organization>
    <address>
      <email>slawrence@pingtel.com</email>
    </address>
    </author>
    <author initials="D." surname="Worley" fullname="Dale Worley">
    <organization>Pingtel Corp.</organization>
    <address>
      <email>dworley@pingtel.com</email>
    </address>
    </author>
    <author initials="W." surname="Gillett" fullname="Walter Gillett">
    <organization>Pingtel Corp.</organization>
    <address>
      <email>walter_gillett@hotmail.com</email>
    </address>
    </author>
    <date day="2" month="December" year="2005"/>
    <area>sipXregistry</area>
  </front>

  <middle>

    <section title="Motivation and Overview">
      <t> For large systems, defined as PBXs with more than a few dozen users, high
        availability (HA) for basic calling is essential: users should be able to make and
        receive phone calls reliably at all times. HA for voice mail, and perhaps some other
        services, is a lower priority although still important. </t>
      <t>
        <spanx style='strong'> In order to deliver HA as quickly as possible, we will start
          by implementing only those features that are absolutely required. The first HA
          implementation in sipXpbx release 3.2 will only address basic calling. Automated
          installation will not be supported; some custom, manual configuration will be
          required. No more than 2 registrars will be allowed. </spanx>
      </t>
      <t> In sipXpbx, basic calling depends on three components: the two proxies and the
        registrar/redirect service. The proxies can be replicated and DNS SRV records can be
        used to share load and provide for failover. The registrar/redirect service,
        however, cannot currently be deployed on multiple servers because the 'soft' state
        in the registry database (mappings from registered Addresses to Contacts) cannot be
        shared. While replicating the proxies alone does help with scaling, the registrar is
        a single point of failure for basic calling service. </t>
      <t> This memo describes a system architecture to provide high availability service for
        basic calling, by adding the required replication of registration information.
        </t>      
    </section>

    <section title="Terminology">
      <list style='hanging'>
        <t hangText='Server'>
          A physical computer system.
        </t>
        <t hangText='Service'>
          A process or processes running on a Server that performs a
          particular function.
        </t>
        <t hangText='Primary Registrar'>
          For a particular REGISTER request, the registrar that receives it
          and performs initial processing for it.
          Note that the Primary Registrar may not be the
          same for successive REGISTER requests, even from one UA.
        </t>
        <t hangText='Replicated Registrar'>
          For a particular REGISTER request,
          any registrar other than its Primary Registrar to which 
          its information is replicated.
        </t>
      </list>
    </section>

    <section title='High Availability Architecture' anchor='arch'>
      <t>
        In an HA configuration, there are at least two types of Server:
      </t>
      <list style='bullet'>
        <t>one Master Server running:</t>
        <list style='bullet'>
          <t>forking proxy</t>
          <t>authentication proxy</t>
          <t>registrar/redirect service</t>
          <t>config service</t>
          <t>vxml service with applications</t>
          <t>publisher (status server)</t>
          <t>presence</t>
        </list>
        <t>one or more Distributed Servers, each running:</t>
        <list style='bullet'>
        </list>
      </list>
      <t>
        Other PBX Services may be distributed among the above Servers,
        or run on other Servers:
      </t>
      <t>
        <spanx style='strong'>
          In Release 3.2, only one configuration will be supported: one
          Distributed Server running only the proxies and registrar/redirect
          service, and one Master Server running all Services.
        </spanx>
      </t>

      <t>
        In order to provide load sharing and failover, all SIP message
        routing to any redundant element in an HA configuration uses DNS
        SRV records.  The following SRV records are required:
      </t>

      <list style='hanging'>
        <t hangText='domain'>
          In a single-system installation, an SRV record that maps the SIP
          domain name to the Server host name is recommended.  In an HA
          installation, multiple SRV records for the SIP domain name are
          required, mapping to the Server names/ports that run the forking proxy
          service.  There are domain SRV records specifying both TCP and
          UDP (with TCP given preference).  For example:
        </t>
       <figure>
         <artwork>
      $ORIGIN example.com.

      _sip._tcp IN SRV   1 50 5060 sipxpbx1
      _sip._tcp IN SRV   1 50 5060 sipxpbx2

      _sip._udp IN SRV 101 50 5060 sipxpbx1
      _sip._udp IN SRV 101 50 5060 sipxpbx2
         </artwork>
       </figure>

        <t hangText='registrar'>
          The <spanx style='verb'>forwardingrules.xml</spanx> for each
          forking proxy service specifies the registrar using an SRV name
          that maps first to the registrar instance on the same Server as
          the proxy (which is quicker to reach and more likely to be
          operational), and then to the registrar instance on the other
          Server (for failover).
          
          The registrar
          service SRV records specify only TCP, because TCP has better
          failure detection and performance characteristics and
          compatibility with User Agents is not required.  
        </t>
       <figure>
         <artwork>
     _sip._tcp.sipxregistrar1 IN SRV 1 50 5070 sipxpbx1
     _sip._tcp.sipxregistrar1 IN SRV 2 50 5070 sipxpbx2

     _sip._tcp.sipxregistrar2 IN SRV 1 50 5070 sipxpbx2
     _sip._tcp.sipxregistrar2 IN SRV 2 50 5070 sipxpbx1
         </artwork>
       </figure>
       <t>
         In the example above, the forking proxy on
         <spanx style='verb'>sipxpbx1</spanx> would
         be configured to use <spanx
         style='verb'>sipxregistrar1</spanx>, which
         preferentially routes to <spanx style='verb'>sipxpbx1:5070</spanx>
         and fails over to
         <spanx style='verb'>sipxpbx2:5070</spanx>.
         The forking proxy on <spanx style='verb'>sipxpbx2</spanx> is
         configured to use
         <spanx style='verb'>sipxregistrar2</spanx>,
         which uses the two Services in the reverse order.
       </t>

       <t hangText='authproxy'>
          The <spanx style='verb'>forwardingrules.xml</spanx> for each
          forking proxy service specifies the authorization proxy
          using a specialized SRV name configured similarly to the SRV
          name for the registrar.
          The
          authorization proxy SRV records specify both TCP and UDP,
          preferring TCP, but allowing UDP for compatibility with User
          Agents that require it.  (The authorization proxy may be
          Record-Routed in dialogs.)
        </t>
       <figure>
         <artwork>
      _sip._tcp.sipxauthproxy1 IN SRV   1 50 5080 sipxpbx1
      _sip._tcp.sipxauthproxy1 IN SRV   2 50 5080 sipxpbx2
      _sip._udp.sipxauthproxy1 IN SRV 101 50 5080 sipxpbx1
      _sip._udp.sipxauthproxy1 IN SRV 102 50 5080 sipxpbx2

      _sip._tcp.sipxauthproxy2 IN SRV   1 50 5080 sipxpbx2
      _sip._tcp.sipxauthproxy2 IN SRV   2 50 5080 sipxpbx1
      _sip._udp.sipxauthproxy2 IN SRV 101 50 5080 sipxpbx2
      _sip._udp.sipxauthproxy2 IN SRV 102 50 5080 sipxpbx1
         </artwork>
       </figure>
       <t>
         The selection technique used to create a preference order for
         registrars is also used for the authproxy, except that SRV
         records for UDP access are also provided, at lower priority
         than all the SRV records for TCP access.
       </t>

       <t>
         <spanx style='strong'>
           Currently, when the authproxy Record-Routes itself, it
           specifies its IP address in the Record-Route header.
           The authproxy could insert a Record-Route that specifies its SRV
           name (as detailed above); doing so would allow
           the processing of in-dialog requests to fail over 
           from one instance to another.
           Whether or not the authproxy should do this depends on
           whether or not user agents support DNS names in Route
           headers.
           Testing is required to determine the best method for Record-Routing.
         </spanx>
       </t>
      </list>
    </section>

    <section title='Current Registrar/Redirect Database Management'>

      <t>
        This section describes the operation of the registrar in
        sipXpbx version 3.0. It does not describe HA changes, or
        the changes for GRUU support.
      </t>

      <section title='Registry Updates'>

        <t>
          Updating the registry is handled by the routine
          SipRegistrarServer::applyRegisterToDirectory and the sibdb
          RegistrationDB class.  The applyRegisterToDirectory method is called
          after the REGISTER request has been authenticated; it validates the
          registration by checking to see if the Call-ID and CSeq are in
          sequence by calling RegistrationDB::isOutOfSequence.
        </t>

        <t>
          applyRegisterToDirectory then parses and validates the contacts
          and expiration time in the
          request and converts them to an internal list.
        </t>

        <t>
          If the request is valid, there are two cases: expiring all
          contacts, and updating contacts.
        </t>
        <list style='hanging'>

          <t hangText='Expiring All Contacts' anchor='expall'>
            If the REGISTER request had an
            '<spanx style='verb'>Expire:&nbsp;0</spanx>' header and 
            just a '<spanx style='verb'>Contact:&nbsp;*</spanx>' header
            then it is requesting that all contacts for this Address
            Of Record (not just those from this
            Call-ID) be expired.  This is done using a single call to:
          </t>
          <figure>
            <artwork>
       RegistrationDB::expireAllBindings( aor, callid, cseq, timeNow )
            </artwork>
          </figure>
          <t>
            The last three arguments to expireAllBindings are not used
            to select which bindings to operate on.  (All bindings for
            the given AOR are expired.)  Rather, they are used for
            marking the bindings as expired -- Bindings are expired by
            setting their expiration time to "timeNow minus 1 second", and
            setting their "last updated by" information to the Call-ID
            and CSeq specified.
          </t>

          <t hangText='Updating Contacts' anchor='upCont'>
            The other case is when there are real contacts in the
            set.  All contacts which are listed are
            to have their expiration times updated, and all other
            contacts which have last been updated with by REGISTERs
            with this Call-ID are to be expired.
          </t>
          <t>
            The listed contacts are updated by calling
            RegistrationDB::updateBinding on each contact:
          </t>
          <figure>
            <artwork>
      RegistrationDB::updateBinding( toUrl, 
                                     contact,     
                                     qvalue,
                                     registerCallidStr, 
                                     registerCseqInt,
                                     expirationTime 
                                     )
            </artwork>
          </figure>
          <t>
            Each contact has its q-value and expiration time set, and the
            Call-ID and CSeq are recorded as its "last updated by" information.
          </t>
          <t>
            After all the contacts in the REGISTER message have been updated,
            any contacts that have the same Call-ID but an earlier CSeq
            number are expired by a single call to:
          </t>
          <figure>
            <artwork>
              RegistrationDB::expireOldBindings( toUrl, 
                                                 registerCallidStr,
                                                 registerCseqInt, 
                                                 timeNow
                                                 )
            </artwork>
          </figure>
        </list>
      </section>

      <section title='Locking'>
        <t>
          Other than the locks internal to FastDB, there are no locks on
          any of the above operations.  This works because only the single
          SipRegistrarServer thread ever writes to the registry database.
        </t>
      </section>
    </section>

    <section title='Changes'>
      
      <t> The following sections detail the changes needed to implement the replicated
        registrar architecture. </t>
      
      <section title='Configuration'>
        <t> An HA Registrar has two additional configuration parameters: </t>
        <list style='hanging'>
          <t hangText='SIP_REGISTRAR_SYNC_WITH'> The host name of the other registrar to
            sync to. (
            <spanx style='emph'>In future versions, this may allow a comma-separated list
              of Servers.</spanx>) </t>
          <t hangText='SIP_REGISTRAR_XMLRPC_PORT'> The port number used by all Servers to
            listen for XML-RPC registry synchronization requests. </t>
        </list>
        
        <t>
          <spanx style='emph'>The set of configuration parameters may be changed in future
            versions of the HA system. Compatibility is only guaranteed with those
            sipXconfig versions which support HA.</spanx>
        </t>
        
      </section>
      
      <section title='Registry Synchronization State'>
        <t> The Registrar Service maintains persistent (across start-ups) state for
          synchronization purposes: </t>
        <list style='hanging'>
          
          <t hangText='DbUpdateNumber'> A numeric ID for update operations to its own
            registry database. DbUpdateNumber is updated only for registrations for which
            this registrar is the Primary Registrar. </t>
          
        </list>
        
        <t> DbUpdateNumber is a positive, signed, 64-bit number composed of two parts: </t>
        <list style='hanging'>
          <t hangText='base time'> The "base time" component in the upper half of
            DbUpdateNumber is a Unix time value, the number of seconds since 00:00 GMT, 1
            January 1970. It is the time at which the registrar last initialized the counter
            component. Since all Servers are expected to have reliable, NTP-synchronized
            clocks, base times created by a Service always increase. Since initializations
            of the update number are expected to be rare, all base times in a system are unique.
            The base time is a 32-bit, positive, signed integer. </t>
          
          <t hangText='counter'> The "counter" component in the bottom half of
            DbUpdateNumber is a 32-bit unsigned integer that is incremented on every update.</t>
        </list>
        
        <t> We need to be able to compare DbUpdateNumbers and decide which one is more
          recent.  However, at 1,000 updates/second, a 32-bit counter will wrap in 1.6 months.
          Because registrations don't stay valid for very long (typically 1 hour), the range
          of DbUpdateNumbers at any point in time is pretty narrow, so we could treat
          DbUpdateNumbers as cyclic, looking at the absolute value of the difference of two
          numbers to see which one is larger.  But this gets complicated.  We can avoid this
          cleverness using a simple trick: rather than wrapping the counter, instead carry
          the overflow bit into the base time value, effectively turning the 32-bit counter
          into a 64-bit counter that will wrap in 292,471,209 years -- not a problem.  Base time
          changes due to overflow can easily be distinguished from base time resets due to
          service restarts, which will increment the base time by much more than a few seconds.</t>
        
        <t> This design allows us to generate unique, monotonic DbUpdateNumbers even if
          we've lost the history for a registry. If that happens, then we initialize the base
          time to the current time and the update number to zero. Since the new base time is both
          most significant and bigger than any previous base times, the new DbUpdateNumbers
          will be bigger than any previous DbUpdateNumbers. </t>
        
        <t>A DbUpdateNumber is used to label the DB records that are modified by a DB update,
          and can be used to designate a particular state of the DB, namely, all record
          modifications with DbUpdateNumber less than or equal to some specified
          DbUpdateNumber. </t>
        
        <t> Since registration state is preserved across restarts, the base time of the local
          DbUpdateNumber will usually not be the same as the start time of the current
          registrar instance. In general, the base time will be the earliest start time from
          which registration state has been kept. </t>
        
        <t> For a given registrar, DbUpdateNumbers for registrations that it handles as the
          primary registrar are referred to as "local". DbUpdateNumbers for registrations
          handled by other registrars and received via updates are referred to "peer". </t>
        
        <list style='hanging'>
          <t hangText='PeerReceivedDbUpdateNumber'> The largest DbUpdateNumber
            received from the peer. </t>
          <t hangText='PeerSentDbUpdateNumber'> The largest DbUpdateNumber sent to the
            peer. </t>
        </list>
        
        <t> The registrar service maintains additional state that is not persistent: </t>
        
        <list style='hanging'>
          <t hangText='PeerReachable'> This is a boolean that indicates whether or not the
            peer is believed to be reachable. It is initialized on startup to
            <spanx style='verb'>false</spanx>, indicating that the peer is not known to be
            reachable. It is set to
            <spanx style='verb'>false</spanx> by most operations if they fail to reach the
            peer, and is set to
            <spanx style='verb'>true</spanx> the RegisterTest thread (see
            <xref target='regtest'/>) when it discovers that it can reach the peer. When it
            is
            <spanx style='verb'>false</spanx>, most operations do not attempt to contact
            the peer. </t>
        </list>
      </section>
      
      <section title='Registration Database'>
        <section title='Additional DB Columns' anchor='dbcolumns'>
          <t> Each row in the registration database (which corresponds to a binding of a
            contact URI to an AOR) gains two columns: </t>
          <list style='hanging'>
            <t hangText='Primary'> A string which is the identifier of the Primary
              Registrar for this binding. This identifier is selected by the Primary
              Registrar, and will usually be the host name of its Server, but the only
              requirement is that each registrar has a distinct identifier. </t>
            <t hangText='UpdateNumber'> The DbUpdateNumber (of the Primary Registrar's DB) of
              the update which inserted or last modified this row. </t>
          </list>
        </section>
        
        <section title='Overall DB Structure'>
          <t> The entries in the registration database maintain the state for registrations
            of contacts for Addresses Of Record. Entries are indexed by AOR, contact, and the
            Call-ID of the sequence of REGISTERs (the registration quasi-dialog) that
            establish and maintain the registration. </t>
          
          <t> Entries are considered to have expired when the current time exceeds the
            expiration time recorded in the entry. The entry is not removed at that time, so
            that the entry can maintain the "last CSeq seen" value for that Call-ID, in case an
            out-of-sequence REGISTER arrives. Entries are removed from the DB after one
            hour after they expire, as we assume that is long enough that out-of-order
            REGISTERS will no longer be in transit. </t>
          
          <t> When a registration is to be expired in advance of its previously scheduled
            expiration time (due to the processing of some REGISTER message), its DB entry is
            modified by reducing its expiration time to one second before the current time.
            </t>
          
          <t> Each entry contains the following fields. (The fields for GRUU support are not
            listed, but they do not affect any of the replication algorithms.) </t>
          
          <list style='hanging'>
            <t hangText='uri'> The AOR of this registration. </t>
            <t hangText='contact'> The contact of this registration. </t>
            <t hangText='qvalue'> The q-value of this registration. </t>
            <t hangText='callid'> The Call-ID of the REGISTERs that establish/maintain
              this registration. </t>
            <t hangText='cseq'> The largest CSeq seen for REGISTERs for this registration.
              </t>
            <t hangText='instance_id'> The
              <spanx style='verb'>+sip.instance</spanx> value that was provided with
              the registration, or the null string. </t>
            <t hangText='gruu'> The GRUU that was assigned to this registration, or the null
              string. </t>
            <t hangText='primary'> The name of the Primary Registrar for this
              registration. </t>
            <t hangText='update_number'> The DbUpdateNumber of the last modification of this
              entry. </t>
          </list>
        </section>
        
      </section>
      
      <section title='Thread Structure and Locking'>
        
        <t> There are three threads in each registrar: </t>
        
        <list style='hanging'>
          <t hangText='RegisterServer'> This thread processes incoming REGISTER
            messages, applying the necessary updates to the DB, and notifying RegisterSync
            thread that when it needs to propagate updates. </t>
          <t hangText='RegisterSync'> This thread is the XML-RPC client that sends updates
            to the peer server. </t>
          <t hangText='RegisterTest'> This thread is the XML-RPC client that tests, when
            the peer Service is thought to be down or unreachable, whether it is now
            reachable. </t>
          <t hangText='HttpServer'> This thread is the XML-RPC server. It must be a separate
            from the XML-RPC client to avoid multi-Server XML-RPC deadlock chains. </t>
        </list>
        
        <t> Registry database updates are protected by an OsMutex; it is taken by
          applyRegisterToDirectory and by each of the registrySync XML-RPC server
          methods. This serializes all the checks for CSeq correctness, and also protects
          the synchronization state variables. </t>
        <t> The XML-RPC client threads (RegisterSync and RegisterTest) will also hold the
          lock when they are modifying the synchronization state, but never while they are
          making XML-RPC calls, in order to avoid mult-Server deadlocks. </t>
        <t>
          <spanx style='emph'> There is no locking between updates to the registry database
            and reads from it by the redirect service; the FastDB ensures sufficient
            integrity that none is needed. </spanx>
        </t>
        
      </section>
      
      <section title='Primary and Secondary Registrars'>
        <t>Every registrar has a unique name, known by all registrars, which will usually be
          its host name. Every REGISTER is processed by the registrar that first receives it,
          which is called the Primary Registrar for the REGISTER, and the Primary Registrar
          is said to "own" that registration and the records describing it (in every
          registrar database). Each Primary Registrar has a set of Replicated Registrars
          that should contain duplicates of all registrations owned by that Primary
          Registrar. Each registrar knows all of the Replicated Registrars for the
          registrations it owns, and also all of the Primary Registrars for which it is a
          Replicated Registrar.
          In addition, each registrar knows the list of its "sibling Replicated
          Registrars", which includes the registrars listed above, and also the registrars
          which are Replicated Registrars for a Primary Registrar for which this registrar
          is a Replicated Registrar. </t>
      </section>
      
      <section title='Processing' anchor='xmlrpcsync'>
        <t> Registrar processing is performed in two stages -- startup and operational.
          During the startup stage, the registrar recovers its local database (if
          possible), then pulls information from all of its sibling registrars. During the
          operational stage, the registrar processes REGISTERs and pushes updates from
          siblings. </t>
        
        <t> The central feature of this design is that during startup and reconstruction of
          the database, the registrar pulls data, so that it can tell when it has finished
          obtaining the data it desires. But during the operational phase, updates are
          pushed by the Primary Registrar to ensure that they are propagated to the
          Replicated Registrars quickly. </t>
        
        <t> The only way a Replicated Registrar can transition from being "dead" to being
          "live" (in the eyes of its Primary Registrar) is through an
          XML-RPC from the Replicated Registrar to the Primary Registrar
          that provides a PeerReceivedDbUpdateNumber for that Replicated
          Registrar.
          . </t>
        
        <t> Processing is done by a number of interlocking operations which are detailed
          below. Synchronization between registrars is done using XML-RPC (see
          <xref target='xmlrpcsync'/>). The XML-RPC URI for these operations always has
          scheme
          <spanx style='verb'>https</spanx> (see
          <xref target='xmlrpcsec'/>), the host name specified by the
          SIP_REGISTRAR_SYNC_WITH configuration item, and the fixed path
          <spanx style='verb'>/RPC2</spanx>. </t>
        
        <section title='RegisterServer -- Register Message Processing'
          anchor='regproc'>
          
          <t> When a REGISTER message has been determined to be valid, the local DB update
            number is incremented, and the changes are applied to the local registry
            database. The local DbUpdateNumber is recorded in each updated row in the
            registry database. The SipRegistrarServer thread then sends a
            PushRegistryUpdate OsMessage to the RegisterSync thread to trigger
            replication to the peer registrar. </t>
          
          <t> In all cases, the Primary Registrar first reduces the effect of the REGISTER to
            the insertion/modification of a number of entries in the DB. The entries are then
            tagged with the Call-ID/CSeq of the REGISTER request, and the local
            DbUpdateNumber of the new version of the DB. It is these records that are then
            propagated to the Replicated Registrar. </t>
          
          <t> This transformation of the REGISTER before propagation is not absolutely
            correct according to RFC 3261, as it does not process "expire all" operations
            correctly in certain uncommon race situations, but it ensures that the results
            of replication are accurately defined (since the processing of the DB updates
            will produce the same result regardless of the order in which they are
            processed). Even in cases where the RFC 3261 result is not produced, the result is
            always the same as would be produced by the same messages if they were received
            with certain small changes in their arrival times. In other
            words, the race condition already exists in 3261, and the
            registry replication does not introduce any problems that were
            not already there.</t>
          
        </section>
        
        <section title='RegisterSync -- Sending Updates to the Peer Server'>
          
          <t> The RegisterSync thread is responsible for propagating updates to the peer
            registrar.
            <spanx style='emph'>(When multiple peers are supported, there may be one
              thread per peer or just one for all peers -- this is a subject for future
              study.)</spanx> </t>
          
          <t> When the RegisterSync thread receives a PushRegistryUpdate message, it
            checks the peer state: If PeerReachable is
            <spanx style='verb'>true</spanx>, and if the local DbUpdateNumber is greater
            than the PeerSent DbUpdateNumber, then registerSync.pushUpdates XML-RPC
            method is used to propagate all updates that have not been sent to the peer (one
            invocation per unsent transaction). After a successful return of the XML-RPC,
            the PeerSent DbUpdateNumber is updated. </t>
          
          <section title='Detailed Operation'>
            
            <t> registrySync.pushUpdates is used by one Registrar to push updates to its
              peer registrar. It is initiated by the RegisterSync thread when it is notified
              that there are (may be) updates in the local DB for which it is the Primary
              Registrar and which have not been propagated to the peer registrar. </t>
            
            <t> First, RegisterSync checks the peer state: If PeerReachable is
              <spanx style='verb'>false</spanx>, it immediately terminates processing
              the PushRegistryUpdate message. (The updates that need to be sent will be sent
              when RegisterTest detects that the peer registry is reachable.) </t>
            
            <t> Next, the RegisterSync thread checks that the local DbUpdateNumber is
              greater than the PeerSent DbUpdateNumber. If not, there are no updates to
              propagate, and the thread terminates processing the message. </t>
            
            <t> If there are updates to propagate, the RegisterSync thread extracts all
              records in the local DB that were updated by this registrar as the Primary
              Register, and whose DbUpdateNumbers are greater than the PeerSent
              DbUpdateNumber. These records are packaged into one or more
              registrySync.pushUpdates XML-RPC calls which are sent in succession to
              the peer registrar. </t>
            
            <t> The XML-RPC server of the peer registrar -- which must be the Replicated
              Registrar for these updates -- first validates that the DbUpdateNumber in the
              XML-RPC is greater than its PeerReceived DbUpdateNumber. If not, this
              XML-RPC is a duplicate of one received previously, and the call can be returned
              successfully without any further work. </t>
            
            <t> The server then applies the updates to its DB in the standard manner. That is,
              it validates that the local database does not have more recent information
              (using the Call-ID and CSeq values) and if not, applies each update to its own
              database. These updates do not increment the local DB update number (since
              they do not need to be identified), and there is no need to trigger this
              registrar's RegisterSync thread to propagate the updates further. </t>
            
            <t> The server then updates its PeerReceived DbUpdateNumber and returns the
              request successfully. </t>
            
            <t> The server also checks its PeerReachable status for the client; if it is
              <spanx style='verb'>false</spanx>, then the server knows that the peer is now
              reachable again, and so it sets its PeerReachable status for the client to
              <spanx style='verb'>true</spanx> and sends a PushRegistryUpdate
              OsMessage to its RegistrySync thread. </t>
            
            <t> When the XML-RPC returns, the client updates its PeerSent DbUpdateNumber,
              and continues with the next set of updates to be sent, or finishes with the
              PushRegistryUpdate message. This allows the registrar to know reliably what
              has been pushed to the peer, since a lost response will cause the update to be
              re-sent. </t>
            
            <t> On any registrySync.pushUpdates failure, the client sets its
              PeerReachable value to
              <spanx style='verb'>false</spanx>, and sends a PeerUnReachable OsMessage
              to the RegisterTest thread. </t>
            
          </section>
          
          <section title='registrySync.pushUpdates method' anchor='pushUpdates'>
            <t>This XML-RPC is used by a registrar during operation to send one or
            more updates that it owns to a Replicated Registrar.</t>
            
            <t>If this XML-RPC fails, the client will mark the server as being
            "dead".</t>
            
            <t>Alternatively, if the server is in the first startup stage, it will
            return an indication, and the client will also mark the server as
            being "dead" to avoid sending further updates which cannot be
            effectively processed during the first startup stage.</t>
            
            <t>It is not yet decided whether a Push Updates can contain
            updates with more than one update number.</t>
            
            <t>The server registrar will apply the updates to its database, and if
            its Last Update Number Received is no less than the starting update
            number, will set its Last Update Number Received to the ending update
            number.</t>
            
            <t>If the server registrar has the client registrar marked "dead", it
            will mark it "live" and queue a Push Updates operation for it.</t>
  
            <t>Inputs:</t>
            <figure>
              <artwork>
     String  registrar_name          Calling registrar name
     int     start_update_number     Update number for first update sent
     int     end_update_number       Update number for last update sent
     array   updates
       struct
         string  uri
         string  callid
         int     cseq
         string  contact 
         int     expires
         string  qvalue
         string  instance_id
         string  gruu
         string  primary
         long long int update_number
            </artwork>
          </figure>

          <t>Outputs:</t>
          <figure>
            <artwork>
     none
            </artwork>
          </figure>
            
            <t> TBD -- The intent of return values was to inform the caller that there were
              unpropagated updates, but I'm not sure that there is anything the caller would
              actually do with that information, so perhaps this should just return the
              value of DbUpdateNumber passed in the transaction (as an acknowledgment).
              </t>
            
          </section>
          
          <section title='registrySync.pullUpdates method' anchor='pullUpdates'>           
            <t>This XML-RPC requests from a registrar all records it holds that are
            owned by the specified registrar whose update numbers are greater than
            the specified starting number.  The returned records are all the
            records that the server has with numbers greater than the starting
            number and less than or equal to the ending number.</t>
            
            <t>It is not yet decided whether the returned records will be only
            records with one update number (in which case all records have the
            same update number, the specified ending update number), or may
            encompass several update numbers.</t>
            
            <t>Alternatively, the call may return an indication that the server has
            no records owned by the specified registrar with higher update
            numbers.</t>
            
            <t>During startup, a registrar uses a series of Pull Update calls to
            download from the other registrars all DB records that it does not
            already have.</t>
            
            <t>If this XML-RPC fails, the client will mark the server as being
            "dead".</t>
            <t>Inputs:</t>
            <figure>
              <artwork>
     String  registrar_name      Owning registrar name
     int     update_number       This RPC contains all records with
                                 update numbers greater than update_number
              </artwork>
            </figure>

            <t>Outputs:</t>
            <figure>
              <artwork>
     array   updates
       struct
         string  uri
         string  callid
         int     cseq
         string  contact 
         int     expires
         string  qvalue
         string  instance_id
         string  gruu
         string  primary
         long long int update_number
              
     long long int  update_number        ending update number (for last update in array)
              </artwork>
            </figure>
          </section>
          
        </section>
        
        <section title='RegisterTest -- Peer Reachability' anchor='regtest'>
          
          <t>
            <spanx style='emph'>The exact implementation of this processing has not yet
              been fixed. This discussion describes the approximate sequence and timing of
              the operations; the mechanism for achieving them may be revised.</spanx>
          </t>
          
          <t> The RegisterTest thread is responsible for determining whether or not a
            previously unreachable peer has become reachable. It is started initially by
            receipt of a PeerUnReachable OsMessage. This causes it to start a timer
            <spanx style='emph'>(duration to be determined)</spanx>; when the timer
            expires, it attempts the registrySync.Check method to test whether or not the
            peer can now be reached. </t>
          
          <t> On a successful return, the caller sets the PeerReachable value to
            <spanx style='verb'>true</spanx>, and the PeerSent DbUpdateNumber from the
            response. The caller then sends a PushRegistryUpdate OsMessage to the
            RegistrySync thread to restart updates to the peer. </t>
          
          <t> Likewise, when this method is invoked, the server sets the PeerReceived
            DbUpdateNumber the arguments, and checks the PeerReachable value. If
            PeerReachable is
            <spanx style='verb'>false</spanx>, it is reset to
            <spanx style='verb'>true</spanx>, and a PushRegistryUpdate OsMessage is
            sent to the RegistrySync thread to restart updates. </t>
          
          <t> On failure, the RegisterTest thread restarts the timer for the peer, using
            standard exponential backoff to a maximum interval of one eighth of the maximum
            registration interval. This prevents useless and possibly harmful traffic
            being injected into the network in the event that the loss of connectivity is
            traffic related. </t>
          
        <section title='registrySync.Check method'>

          <t>Inputs:</t>
          <figure>
            <artwork>
  string         Name                          The sender's identifier
  long long int  PeerReceivedDbUpdateNumber    The current value of the sender's 
                                               PeerReceivedDbUpdateNumber.
            </artwork>
          </figure>

          <t>Outputs:</t>
          <figure>
            <artwork>
  long long int  PeerReceivedDbUpdateNumber    The current value of the recipient's 
                                               PeerReceivedDbUpdateNumber
            </artwork>
          </figure>
          <t> This XML-PRC is used by a client registrar during operation to inquire of the
          server registar whether it is operational, and to reset the peer's PeerSentDbUpdateNumber
          to match the client's input argument PeerReceivedDbUpdateNumber.
          If this XML-RPC fails, the client will continue to consider the
          server as being "dead".  Also, if the server is in the first startup
          stage, it will return an indication, which the client will treat as
          failure.</t>
          
          <t> If the server is operational, it will mark the client as "live", set its
          PeerSentDbUpdateNumber for the client to the argument value, and
          queue a Push Updates for the client if there are updates to send.
          The server returns its PeerReceivedDbUpdateNumber for the client.</t>
          
          <t> If this XML-RPC succeeds, the client marks the server as "live", sets
          its Last Update Number Sent for the server to the return value, and
          queues a Push Updates for the server.</t>
        </section>
        </section>
        
        <section title='Startup Processing' anchor='startup'>
          <t> When the registrar service starts, it attempts to read its own persistent
            registry store. If successful, it restores all state variables from the store.
            If not, then it:</t>
          <list style='bullet'>
            <t> Initializes its
             local database DbUpdateNumber by setting the base time in the upper word from
             the current time and the counter in the lower word to zero.</t>
            <t> Sets the PeerSent DbUpdateNumber and PeerReceived DbUpdateNumber to zero.</t>
          </list>
          
          <t> Because the PeerReceived DbUpdateNumber includes the peer's base time, a
            registrar service can detect when a peer has restarted and lost
            synchronization state. </t>
          
          <t> At startup, the server needs to discover quickly whether or not the local
            registry is the best available source of contact information. Before this is
            determined, the server does not open its redirector SIP port, so that clients
            will consider it to be down and fail over to another server. A fairly elaborate
            process is needed to handle this situation well. </t>
          
          <t> Declare the peer registrar to be "live" (until proven otherwise).
            Make a Pull Updates request to the peer for records
	          owned by the peer, starting from PeerReceived DbUpdateNumber.
            If this registrar is restarting with no persistent state, then
            make a Pull Updates request to the peer for records
	          owned by this registrar, starting from DbUpdateNumber = 0.
            If either of these requests fails then mark the peer as "dead".</t>
          
          <t> At this point, the database contains all available registration records
            for either registrar.  To finish startup processing</t>
          <list style='bullet'>
          <t> Set the operational live/dead indicators to "dead".</t>
          <t> Queue a Check operation for the peer registrars.</t>
          <t> Begin accepting Push Updates and Check XML-RPCs.</t>
          <t> Begin accepting REGISTERs and redirection requests.</t>
          </list>
        </section>
        
      </section>
      
      <section title='XML-RPC Security' anchor='xmlrpcsec'>
        <t> Registry synchronization requests require that the RPC connection be
          SSL-authenticated as coming from a Server in the same SIP domain. </t>
        <t>
          <spanx style='strong'> Initially, all synchronized Servers will use the same key
            and certificate. </spanx>
        </t>
        
      </section>
      
      <section title='HTTP Persistent Connections'>
        
        <t> Because these updates will be quite frequent compared to any previous use of
          XML-RPC, and because they must be over SSL connections, we may need to modify our
          HTTP to support persistent connections. We have a design for this based on how SIP
          TCP connections are done.
          <spanx style='emph'>Whether or not this will be included in the 3.2 release
            depends on available time and the results of performance testing once
            synchronization is working.</spanx> </t>
        
      </section>
      
      <section title='Authorization Proxy Record-Route' anchor='authrrsv'>
        <t> Ideally, the authproxy Record-Routes should use the SRV record name as described
          in
          <xref target='arch'/>. Using that mechanism, and assuming the phones support SRV
          record names in Record-Routes correctly, then in-dialog requests (like 'on/off
          hold') would fail over from one authproxy to another.
          <spanx style='strong'>But phones that could not process an SRV name in a
            Record-Route would be unable to perform any in-dialog requests.</spanx> </t>
        <t>
          <spanx style='emph'>At this time, the plan is to not change how the Record-Route is
            constructed (continue using the IP address rather than use the SRV
            name).</spanx>
        </t>
      </section>
      
    </section>

</middle>
<back>
</back>

</rfc>
