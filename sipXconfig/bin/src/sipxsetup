#!/usr/bin/env ruby

require 'getoptlong'

class Setup

  # Default implementation is a Redhat system
  def initialize(system = RedhatSystem.new)
    @system = system
  end
  
  def show_modified
    packages = @system.packages
    packages.each do |package|
      @system.modified_files(package).each do |file|
        @system.puts file
      end
    end
  end

  def prepare_for_upgrade
    @system.perform_backup
  end
  
  def finish_upgrade  
    success = true
    unresolved = @system.unresolved_backup_files(@system.configuration_files)
    unresolved.each do |backup_file|
      if resolve(backup_file) 
        @system.delete_file(backup_file)
      else
        success = false
        @system.puts "Could not automatically resolve file #{file}"
      end
    end
    return success
  end
  
  def resolve(file)
    master = @system.backup_master_file(file)
    patch = @system.create_patch(master, file)
    if @system.test_patch(master, patch)
      @system.apply_patch(master, patch)
      return true
    end
    return false
  end
end

# Isolate system calls so other distros can implement respective 
# commands AND so calls can be stubbed out for unitttests 
class SystemService

  @@binDir = '@sipxpbx.bin.dir@'
  @@patch = 'patch'
  @@diff = 'diff'
  
  def initialize()
    @console = $stdout;
  end
  
  def console(message) 
    @console.puts(message)
  end
  
  def delete_file(file)
    File.delete(file)
  end

  def perform_backup
    `#{@@binDir}/backup-configs.sh`
  end
  
  def create_patch(masterFile, oldFile)
    return `#{@@diff} --unified #{masterFile} #{oldFile}`    
  end
    
  def test_patch(masterFile, patch)
    IO.popen("#{@@patch} --unified --dry-run #{masterFile}", "w") {|pipe|
      pipe.puts patch
    }
    return "#{$?}" == "0"
  end

  def apply_patch(masterFile, patch)
    IO.popen("#{@@patch} --unified #{masterFile}", "w") {|pipe|
      pipe.puts patch
    }
  end
  
end

class RedhatSystem < SystemService

  def packages
    return `rpm -qa | grep sipx`.split
  end
  
  def modified_files(package)
    modified = Array.new
    modified_line = `rpm --query --verify #{package}`.split("\n")
    modified_line.each do |line|
      modified.add line.split.last
    end
    return modified
  end
  
  def configuration_files
    files = Array.new
    packages.each do |package|
      files.add `rpm --query --configfiles #{package}`.split("\n")
    end
    return files
  end
  
  # %config(noreplace) filename and file was modified by end user
  def unresolved_backup_files(configuration_files)
    unresolved = Array.new
    configuration_files.each do |file|
      unresolved.add file if File.exists? file+".rpmnew"
    end
    
    return unresolved
  end
  
  def backup_master_file(filename)
    return filename.chomp(".rpmsave")
  end
  
end


def usage_exit
      usage = <<__EOU__
  Usage:
    #{ $0 } --show-modified
  Show configuration files that have been modified.

__EOU__

      STDERR << usage
      exit 1
end

if __FILE__ == $0
  OptSet = [
    ['--show-modified','-m', GetoptLong::NO_ARGUMENT],
    ['--help','-h', GetoptLong::NO_ARGUMENT],
  ]

  opts = GetoptLong.new(*OptSet)
  begin
    action = nil
    opts.each do |name, arg|
      case name
        when "--show-modified"
          action = "show_modified"
        else
          usage_exit
        end
    end
  rescue
    usage_exit
  end

  begin

  setup = Setup.new
  setup.send(action)

  end
end

