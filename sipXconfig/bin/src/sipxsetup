#!/usr/bin/env ruby

require 'getoptlong'

class Setup

  # Default implementation is a Redhat system
  def initialize(system = RedhatSystem.new)
    @system = system
  end
  
  def show_modified
    packages = @system.packages
    packages.each do |package|
      @system.modified_files(package).each do |file|
        @system.console file
      end
    end
  end

  def prepare_for_upgrade
    @system.perform_backup
  end
  
  def finish_upgrade  
    success = true
    unresolved = unresolved_backup_files
    unresolved.each do |master_file|
      if resolve(master_file) 
        @system.delete_file(@system.backup_filename(master_file))
      else
        success = false
        @system.console "Could not automatically resolve file #{master_file}"
      end
    end
    return success
  end
  
  def resolve(master)
    backup = @system.backup_filename(master)
    patch = @system.create_patch(master, backup)
    if @system.test_patch(master, patch)
      @system.apply_patch(master, patch)
      return true
    end
    return false
  end
  
  def show_unresolved
    unresolved_backup_files.each do |file|
      @system.console file
    end
  end

  # %config(noreplace) filename and file was modified by end user
  def unresolved_backup_files
    unresolved = []
    @system.configuration_files.each do |file|
      unresolved.push file if @system.file_exists(@system.backup_filename(file))
    end
    
    return unresolved
  end

end

# Isolate system calls so other distros can implement respective 
# commands AND so calls can be stubbed out for unitttests 
class SystemService

  @@binDir = '@sipxpbx.bin.dir@'
  @@patch = 'patch'
  @@diff = 'diff'
  
  def initialize()
    @console = $stdout;
  end
  
  def console(message) 
    @console.puts(message)
  end
  
  def delete_file(file)
    File.delete(file)
  end
  
  def file_exists(file)
    return File.exists?(file)
  end

  def perform_backup
    `#{@@binDir}/backup-configs.sh`
  end
  
  def create_patch(masterFile, oldFile)
    return `#{@@diff} --unified #{masterFile} #{oldFile}`    
  end
    
  def test_patch(masterFile, patch)
    IO.popen("#{@@patch} --unified --dry-run #{masterFile}", "w") {|pipe|
      pipe.puts patch
    }
    return "#{$?}" == "0"
  end

  def apply_patch(masterFile, patch)
    IO.popen("#{@@patch} --unified #{masterFile}", "w") {|pipe|
      pipe.puts patch
    }
  end
  
end

class RedhatSystem < SystemService

  def packages
    return `rpm -qa | grep sipx`.split
  end
  
  def modified_files(package)
    modified = []
    modified_line = `rpm --query --verify #{package}`.split("\n")
    modified_line.each do |line|
      modified.push line.split.last
    end
    return modified
  end
  
  def configuration_files
    files = []
    packages.each do |package|
      files.push `rpm --query --configfiles #{package}`.split("\n")
    end
    return files
  end
  
  def backup_filename(master_filename)
    return master_filename + '.rpmnew'
  end
  
end


def usage_exit
      usage = <<__EOU__
  Usage: #{ $0 } command

  Commands:
     --show-modified    Show configuration files that have been modified.
     --show-unresolved  Show configuration files that need to be resolved
                        after an upgrade.
__EOU__

      STDERR << usage
      exit 1
end

if __FILE__ == $0
  OptSet = [
    ['--show-modified','-m', GetoptLong::NO_ARGUMENT],
    ['--show-unresolved','-u', GetoptLong::NO_ARGUMENT],
    ['--help','-h', GetoptLong::NO_ARGUMENT],
  ]

  opts = GetoptLong.new(*OptSet)
  begin
    action = nil
    opts.each do |name, arg|
      case name
        when "--help"
          usage_exit
        else
          OptSet.each do |option|
            if name == option[0]
              action = option[0].slice(2..-1).gsub(/[-]/, "_")
            end
          end
        end
    end
  rescue
    usage_exit
  end

  begin
  usage_exit if !action
  setup = Setup.new
  setup.send(action)

  end
end

