#! /bin/bash

# Program configuration.
SIPTEST=siptest

# Test driver system configuration
MY_ADDRESS=10.1.1.139
FROM_USER_AOR=Q

# Output help message if no arguments, --help, or -h.
if [[ "$1" == --help || "$1" == -h || $# == 0 ]]
then
    cat <<-EOF
	To install:

	Edit the definitions at the top of the script:

	SIPTEST is the location of the siptest program.
	MY_ADDRESS is the IP address or DNS name of this host.

	To run:

	Beware that some phones will not send dialog events correctly if
	they are not registered with a PBX.

	Three arguments are mandatory:

	-a/--addr - specify IP or DNS address of the phone
	-p/--phone - model name of the phone
	-l/--line - SIP user name (line number) for calling the phone

	(It is useful to run the script for line numbers the phone is not
	configured for as well as line numbers that it is configured for.)

	This script will execute one SUBSCRIBE and four INVITES over about
	a minute.  When the phone rings, you can answer it, or better, reject
	the call.  Do not leave them ringing -- some phones do not clear them
	promptly.

	An optional argument is:

	-s/--second - specify SIP user name of a second line on the phone

	Causes INVITEs to the second line to be generated to see if
	they are reported on the dialog events for the first line.
	Increases the number of INVITEs to nine.

	Output is stored in files named
	"log_[phone]_[line]@[addr]_[n]{a,b,c}".  The integer n is chosen to
	avoid writing over existing files.  The suffixes "a", "b", and "c"
	designate progressively more processed forms of the output.

	Run in a scratch directory, as it generates temporary files.
EOF
    exit 1
fi

# Process the arguments.

function get_arg ()
{
    # $1 is the variable
    # $2 is the option argument
    # $3 is the value
    # $4 is the description of the variable

    # Check whether the value has been set already.
    eval "X=\$$1"
    if [[ -n "$X" ]]
    then
	echo >&2 "Argument '$2' duplicates previous specification of $4."
	exit 1
    fi
    # Check whether the value is empty.
    if [[ -z "$3" ]]
    then
	echo >&2 "Empty or no value given for argument '$2'."
	exit 1
    fi
    # Set the value.
    eval "$1=\"$3\""
}

while [ $# -ne 0 ]
do
  case "$1" in
        -a)
	get_arg PHONE_ADDR "$1" "$2" "phone address"
	shift ; shift
	;;

        -a?*)
	get_arg PHONE_ADDR "$1" "${1#-a}" "phone address"
	shift
	;;

        --addr=*)
	get_arg PHONE_ADDR "$1" "${1#--addr=}" "phone address"
	shift
	;;

        -p)
	get_arg PHONE_NAME "$1" "$2" "phone model name"
	shift ; shift
	;;

        -p?*)
	get_arg PHONE_NAME "$1" "${1#-p}" "phone model name"
	shift
	;;

        --phone=*)
	get_arg PHONE_NAME "$1" "${1#--phone=}" "phone model name"
	shift
	;;

        -l)
	get_arg TO_USER_LINE "$1" "$2" "user name"
	shift ; shift
	;;

        -l?*)
	get_arg TO_USER_LINE "$1" "${1#-l}" "user name"
	shift
	;;

        --line=*)
	get_arg TO_USER_LINE "$1" "${1#--line=}" "user name"
	shift
	;;

        -s)
	get_arg TO_USER_LINE2 "$1" "$2" "second user name"
	shift ; shift
	;;

        -s?*)
	get_arg TO_USER_LINE2 "$1" "${1#-s}" "second user name"
	shift
	;;

        --second=*)
	get_arg TO_USER_LINE2 "$1" "${1#--second=}" "second user name"
	shift
	;;

        *)
	echo >&2 "Invalid argument '$1'."
	exit 1
	;;
  esac
done

# Check that required parameters are present.
if [[ -z "${PHONE_ADDR}" ]]
then
    echo >&2 "No -a/-addr specified to give address of phone."
    exit 1
fi
if [[ -z "${PHONE_NAME}" ]]
then
    echo >&2 "No -p/-phone specified to give phone model name."
    exit 1
fi
if [[ -z "${TO_USER_LINE}" ]]
then
    echo >&2 "No -l/-line specified to give user name on phone."
    exit 1
fi

# Target phone configuration
TO_USER_AOR=C

# Functions to generate Call-Ids and tags.
Call_Id_sequence_no=0
Call_Id_base=$$-$( date --iso-8601=seconds )@${PHONE_ADDR}
function generate_Call_Id ()
{
    (( Call_Id_sequence_no++ ))
    C=${Call_Id_sequence_no}-${Call_Id_base}
}

tag_sequence_no=0
function generate_tag ()
{
    (( tag_sequence_no++ ))
    T=t${tag_sequence_no}
}

cat /dev/null >temp.W1

(
  echo
  echo Send SUBSCRIBE ${TO_USER_LINE}@${PHONE_ADDR} with To: ${TO_USER_AOR}@${PHONE_ADDR}
  echo
) | tee -a temp.W1

# Generate a SUBSCRIBE.
generate_Call_Id
C1=${C}
generate_tag
T1=${T}
cat <<-EOF >temp.U1
	SUBSCRIBE sip:${TO_USER_LINE}@${PHONE_ADDR} SIP/2.0
	From: sip:${FROM_USER_AOR}@${MY_ADDRESS};tag=${T1}
	To: sip:${TO_USER_AOR}@${PHONE_ADDR}
	Call-Id: ${C1}
	CSeq: 1000 SUBSCRIBE
	Event: dialog
	Expires: 100

EOF

# Send the SUBSCRIBE.
${SIPTEST} <<-EOF >>temp.W1
	send temp.U1
	sleep 10
	log dump
EOF

# Generate a variety of INVITEs.

for REQUEST_USER in ${TO_USER_AOR} ${TO_USER_LINE} ${TO_USER_LINE2}
do
  for TO_USER in ${TO_USER_AOR} ${TO_USER_LINE} ${TO_USER_LINE2}
  do

    (
      echo
      echo Send INVITE ${REQUEST_USER}@${PHONE_ADDR} with To: ${TO_USER}@${PHONE_ADDR}
      echo
    ) | tee -a temp.W1

    # Generate an INVITE for a call.
    generate_Call_Id
    generate_tag
    cat <<-EOF >temp.U
	INVITE sip:${REQUEST_USER}@${PHONE_ADDR} SIP/2.0
	From: sip:${FROM_USER_AOR}@${MY_ADDRESS};tag=${T}
	To: sip:${TO_USER}@${PHONE_ADDR}
	Call-Id: ${C}
	CSeq: 1000 INVITE

	EOF

    # Send the INVITE.
    ${SIPTEST} <<-EOF >>temp.W1
	send temp.U
	sleep 10
	log dump
	EOF

  done
done

# Process the log files.

<temp.W1 >temp.W2 sed \
    -e '/SipUserAgent::.* sent message:\|Read SIP message:/,/--------------------END--------------------\|====================END====================/!d' \
    -e $'s/\015//'

<temp.W2 >temp.W3 sed \
    -e 's%</dialog-info>.*$%</dialog-info>%' \
    -e '/<dialog-info\|^INVITE/,/<\/dialog-info>\|^$/!d' \
    -e $'/<\\/dialog-info/a\\\n' \
    -e '/^\(Cseq:\|Date:\|Max-Forwards:\|User-Agent:\|Accept-Language:\|Allow:\|Via:\|Content-Length:\)/d'

# Select base for log file names.
(( i = 1 ))
while LOG_BASE="log_${PHONE_NAME}_${TO_USER_LINE}@${PHONE_ADDR}_$i"
      [[ -e ${LOG_BASE}a || -e ${LOG_BASE}b || -e ${LOG_BASE}c ]]
do
  (( i++ ))
done

# Save the output.
mv temp.W1 ${LOG_BASE}a
mv temp.W2 ${LOG_BASE}b
mv temp.W3 ${LOG_BASE}c
