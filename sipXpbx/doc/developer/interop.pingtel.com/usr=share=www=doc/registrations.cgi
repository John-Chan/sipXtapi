#! /usr/bin/perl

use CGI qw/:standard/;
use XML::Parser;
use strict;

# The un-escape table for backslash escapes.
my(%unescape) = ("r", "\r",
		 "n", "\n",
		 "\"", "\"",
		 "\\", "\\");

my($registration_file) = $ARGV[0] || '/var/sipxdata/sipdb/registration.xml';

# Read and process the registrar log files.
my(%user_agent);
# Read at least 24 hours of log data in chronological order.
&process_log_file('/var/log/sipxpbx/sipregistrar.log.1');
&process_log_file('/var/log/sipxpbx/sipregistrar.log');

# Read and parse the registrations file.
my($parser) = new XML::Parser(Style => 'Tree');
my($tree) = $parser->parsefile($registration_file);

# Extract the information about the registrations.
my @registrations;
if ($tree->[0] eq 'items') {
    my $c = $tree->[1];
    my $i;
    my($timestamp) = $c->[0]->{'timestamp'};
    for ($i = 1; $i < $#$c; $i += 2) {
	if ($c->[$i] eq 'item') {
	    my($d) = $c->[$i+1];
            my($i);
	    # Create the hash to contain the information about this
	    # registration.
	    my($registration) = {};
	    for ($i = 1; $i < $#$d; $i += 2) {
                my($e) = $d->[$i];
                my($f) = $d->[$i+1];
                if ($e eq 'callid') {
		    $registration->{'callid'} = &text($f);
                } elsif ($e eq 'cseq') {
                    $registration->{'cseq'} = &text($f);
                } elsif ($e eq 'uri') {
                    $registration->{'AOR'} = &text($f);
                } elsif ($e eq 'contact') {
                    $registration->{'contact'} = &text($f);
                } elsif ($e eq 'qvalue') {
                    $registration->{'q'} = &text($f);
                } elsif ($e eq 'expires') {
                    $registration->{'expires'} = &text($f) - $timestamp;
                } elsif ($e eq 'instance_id') {
                    $registration->{'instance_id'} = &text($f);
                } elsif ($e eq 'gruu') {
                    $registration->{'gruu'} = &text($f);
		}
	    }
	    # Add to the array of registrations.
	    push(@registrations, $registration);
        }
    }
} else {
    # Crash if the registrations file is unparsable.
    exit 1;
}

# Generate the table body in order by extension.
my($table_body) = '';
my($registration);
foreach $registration (sort registration_cmp @registrations) {
    # Ignore registrations that have expired.
    if ($registration->{'expires'} > 0) {
	my($AOR) = $registration->{'AOR'};
	my($extension) = $AOR =~ /sips?:(\d+)@/;
	$table_body .= 
	    &Tr(&td([
		     &code(&escapebreak($AOR)),
		     &code(&escapebreak($registration->{'contact'})),
		     &code(&escapebreak($user_agent{$extension})),
		     &escapeHTML($registration->{'q'})]),
		&td({-align => 'right'},
		    &escapeHTML($registration->{'expires'})),
		&td([
		     &code(&escapebreak($registration->{'instance_id'})),
		     &code(&escapebreak($registration->{'gruu'})),
		     &code(&escapebreak($registration->{'callid'}))]),
		&td({-align => 'right'},
		    &escapeHTML($registration->{'cseq'})
		    )) . "\n"
	       }
}

# Start the HTML.
print &header,
    &start_html('Registrations'), "\n",
    &h1('Registrations'), "\n";

# Beware that <tr> is generated by the Tr() function, because tr is a
# keyword.
print &p(&table({-border => 1, -align => 'left'},
		&Tr(&th([
			 'AOR',
			 'Contact',
			 'User-Agent',
			 'q',
			 'Expires',
			 'Instance ID',
			 'GRUU',
			 'Call-Id',
			 'CSeq'
			 ])), "\n",
		$table_body)),
    "\n";

# Print the boilerplate.
print <<EOF;
<p>&nbsp;</p>
<p>"AOR" is the address of record for which the contact is registered.<br/>
"Contact" is the contact address which is registered.<br/>
"User-Agent" is the value from the User-Agent header in the REGISTER.<br/>
"q" is the q-value which shows the preference of this contact for this AOR
(1.0 = highest, 0.0 = lowest).<br/>
"Expires" is the number of seconds until this registration expires.<br/>
"Instance ID" is the <code>+sip.instance</code> given for this contact.
Registrations for extensions <code>1gg7</code>, <code>1gg8</code>, and
<code>1gg9</code> will have their <code>+sip.instance</code> values removed
and so will not be assigned GRUUs.<br/>
"GRUU" is the GRUU that was assigned for this contact.
A GRUU will only be assigned if a <code>+sip.instance</code> was provided.<br/>
"Call-Id" is the Call-Id of the REGISTER request that established this
registration.
Multiple registrations for the same contact with different
Call-Id values show that the UA is incorrectly using different Call-Id values
for successive REGISTERs.<br/>
"CSeq" is the CSeq number of the REGISTER.
A <font color='red'>red</font> value means that the UA has incorrectly
sent more than 2 registrations in the last 5 minutes, which means that
it is re-registering too frequently.</p>
EOF

# End the HTML.
print &end_html,
    "\n";

exit 0;

# Extract the (top-level) text content from an XML tree.
sub text {
    my($tree) = @_;
    my($text) = '';
    my $i;
    for ($i = 1; $i < $#$tree; $i += 2) {
	if (${$tree}[$i] eq '0') {
	    $text .= ${$tree}[$i+1];
        }
    }
    return $text;
}

# Function to compare two registration hashes.
sub registration_cmp {
    # Extract the AOR fields and from them extract the extension number.
    my($a_ext) = $a->{'AOR'} =~ /sip:(\d+)\@/;
    my($b_ext) = $b->{'AOR'} =~ /sip:(\d+)\@/;
    # Compare the extensions numerically.
    return $a_ext <=> $b_ext;
}

# Extract the user-agent info from a log file.
sub process_log_file {
    my($log_file) = @_;
    my($extension, $user_agent);

    # Read through the log file and find all the REGISTERs.
    my($log_line) = '';
    open(LOG, $log_file) ||
	die "Error opening file '$log_file' for input: $!\n";
    while (<LOG>) {
	next unless /:INCOMING:/;
	next unless /----\\nREGISTER\s/i;
	# This line passes the tests, process it.

	# Normalize the log line.
	s/^.*?----\\n//;
	s/====*END====*\\n"\n$//;
        s/\\(.)/$unescape{$1}/eg;
        s/\r\n/\n/g;

        # Get the extension and User-Agent headers.
        ($extension) = /\nTo:.*?sips?:(\d+)@/i;
        ($user_agent) = /\nUser-Agent:\s*(.*)\n/i;

        # Save the values.
        $user_agent{$extension} = $user_agent if $extension && $user_agent;
    }
    close LOG;
}

# Replace an empty HTML string with "&nbsp;", so IE won't consider a table
# element to be absent.
sub non_empty {
    my($string) = @_;

    return $string eq '' ? "&nbsp;" : $string;
}

sub segment {
    my($string) = @_;

    $string = substr($string, 0, 10) . "<wbr/>" . substr($string, 10);
    return $string;
}

# Escape text to represent it in HTML.
# Also, insert <wbr/> tags to allow breaks between all characters.
sub escapebreak {
    my($string) = @_;

    my(@chars) = split(//, $string);
    @chars = map { $_ eq '<' ? '&lt;' :
		       $_ eq '>' ? '&gt;' :
		       $_ eq '&' ? '&amp;' :
		       $_ eq ' ' ? '&nbsp;' :
                       $_ } @chars;
    return join('<wbr/>', @chars);
}

