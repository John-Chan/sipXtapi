<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

 <head>
  <title>Architecture</title>
  <link rel="stylesheet" type="text/css" href="manual.css"/>

</head>
<body id="architecture">

<h1>Configuration Server Architectural Design</h1>

<p>The purpose of this document is to give a high level description of the components and technologies that make up
  the Configuration Server. Additionally this document was prepared by sipXconfig team to outline the process of
  rewriting sipXconfig to transform it into open source, extensible platform for management of SIP elements.</p>

<h2>Product Description</h2>

<p>sipXconfig is a management tool designed to automate and simplify the provisioning and operation of a network of
  SIP phones. It is our goal to evolve sipXconfig into open platform for mass deploying and monitoring SIP related
  components. Our customers are both end users (system administrators) who are deploying SIP-based solutions and
  developers who are adding support for phones, ATAs, gateways and other elements of sip infrastructure.</p>

<p>We want sipXconfig to provide a typical services (profile generation, user management, management UI, log
  viewer, statistic analyzer) and a plug-in architecture for supporting specific phones, gateways, proxies. We
  hope that developers and system integrators will be able to assemble sipXconfig based solutions by selecting
  self-contained services and plug-ins.</p>

<p>It is our vision that support for configuration and monitoring of new entities can be easily incorporated in
  sipXconfig system by reusing sipXconfig provided services and developing light weight, model driven
  configuration plug-ins.</p>

<p>Additionally developers should be free to develop parallel services - for example additional, fat client UI
  rendering engine - and use it to create different incarnations of sipXconfig framework. The sipXconfig platform
  will remain open to allow for internal and community-wide development of functionality. </p>

<p>We recognize necessity of insuring that sipXconfig platform remains extensible and open. Wherever possible we
  will implement sipXconfig services employing &quot;extension point&quot; architecture: developers should
  be able to modify and extend the system by registering external services or extending existing services.</p>

<h2>sipXconfig services</h2>

<p>As a pluggable framework sipXconfig should be seen as an enabling technology for developing useful solutions.
  We cannot possibly enumerate today all services that may be part of the platform. Below you can find one of the many
  possible classifications of sipX services. Some of those are already part of the framework, some are used but not
  exposed in a way that would enable developers to employ them when designing sipX based solutions, some may be only
  implemented in the future. </p>

<p><img src="images/sipxconfig-services.png" alt="sipXconfig services"/></p>
  
<p>The following classification is just a high level draft of what's possible inside of the sipXconfig
  framework.</p>
  
<h3>Modeling and persistence service:</h3>
<ul>
  <li>structured settings persistence service - automatic configuration persistence for modeled devices</li>
  <li>configuration backup and restore</li>
  <li>ORM database access</li>
  <li>flexible migration strategies of persistent settings to support advances in devices being modeled and
    advances in framework itself</li>
</ul>

<h3>Transport services:</h3>
<ul>
	<li>TFTP server integration</li>
	<li>SNMP client</li>
	<li>SIP</li>
	<li>HTTP(S)</li>
</ul>    

<h3>Management services</h3>
<ul>
	<li>profile generator - template based generation of configuration data</li>
	<li>event sinks - for persisting logs, traps etc.</li>
	<li>update service - automatic and on-demand configuration updates for managed elements</li>
	<li>monitoring, statistics gathering, customized status and trouble-shooting reports</li>
</ul>

<h3>UI rendering engines</h3>
<ul>
  <li> settings editors - ability to display and edit multiple types of settings (strings, list, enumerations,
    sets) using WEB based UI; ability to group settings into sets,
  </li>
  <li> localization support - all rendering engines will provide internationalization capability which should
    include all elements of user interface: text, graphics, on-line help system</li>
  <li> pervasive search capabilities</li>
  <li> creating configuration wizards on top of basic setting-based interface</li>
  <li> OEM support - in addition to internationalization the UI engine will fully support complete customization
    for OEM purposes</li>  
</ul>
  
<h3>Automation API services</h3>
<ul>
  <li> secure, simple and script-able API for automating interaction with sipXconfig system</li>
  <li> physical and logical decoupling of sipXconfig from other parts of sipX framework</li>
</ul>
  
<h3>Framework services</h3>
<ul>
  <li> cross-platform installation</li>  
</ul>
  
<h2>Technical details</h2>
<h3>Application servers - JBoss etc.</h3>
  
<p>While JBoss is an excellent application server we cannot really justify using it in sipXconfig. JBoss seems to
  shine in enterprise class application, handling thousands of simultaneous transactions. We need something
  smaller, easier to install, faster to start. </p>
  
<p>We suspect that JBoss complexity may hinder wider acceptance of sipXconfig by both users and developers.
  Because of that we are planning to gradually reduce the dependence on JBoss and EJB technology and replace its
  parts with widely accepted IOC container (Spring), ORM library (Hibernate) and component-based WEB UI library
  (Tapestry).</p>
  
<h3>Default UI engine</h3>
  
<p>At the moment sipXconfig support a thin client, WEB based interface, but we are leaving the option of supporting
  additional rendering engines open. To implement current UI engine we will use only W3C accepted technologies:
  XHTML for presentation, CSS for styling and customization, limited client side scripting for usability
  improvements.</p>

<p>We chose Tapestry to implement UI layer because it combines 2 important properties:</p>
<ul>
  <li> allows developers to have very detailed control over HTML, CSS and Java script</li>
  <li> hides complexities of those low level technologies by allowing to define higher level re-usable
    components.</li>
</ul>
  
<p>To our best knowledge other WEB technologies, while providing some specific benefits, do not combined low level
  control and high level usability in a similarly elegant manner.</p>
  
<h3>Other libraries and tools - selection criteria</h3>

<p>We consider Java standard library and Jakarta commons library to be an accepted java core. We hope that packaging
  of Java components pretty soon achieves the level of maturity enjoyed by other libraries and tools in Linux world
  and that we will be able to stop bundling a lot of libraries that we use with sipXconfig, thus reducing the package
  size and simplifying installation.</p>
  
<p>We would like to use the best tools available. By the best we mean not only the fastest and newest. The wide
  acceptance in an open source community, availability of platform specific ports (which is less of a problem in
  Java world), simplicity of configuration are important factors for us.</p>
  
<p>When possible we will use just one library for one task. For example we will attempt to reduce that number of XML
  parsers or database access methods.</p>
  
<p>We will favor non-invasive, aspect based solutions. We want as much code as possible to be written as plain Java
  objects, easy to test and reusable on many platforms.</p>
  
<p>Approval of open source community is an important factor in selecting libraries and tools for sipXconfig.</p>
  
<h2>Development Process</h2>

<p>What's not automated is not part of the process. We automatically check the code quality (checkstyle), test it
  (junit and family) and check the test coverage (clover). We maintain incremental and full builds on several
  platforms. In future we also intend to automatically check the performance of the sipXconfig,</p>

<p>Test driven design and development is the underlying principle of the sipXconfig development process.
  Testability influences our design decision, the choice of the tools and libraries. We are suspicious of the code
  that cannot be automatically tested and we will be gradually eliminating such code.</p>

<p>We prefer to &quot;design as we go&quot; approach to upfront design methodologies. It is our firm belief that it
  is always easier to extend simple design than to fix an over-engineered one. We will only optimize the design when
  new features are requested or when problems arise.</p>

<p>Although strict in how we accept contributions, we adopt Eclipse's philosophy that everything is a
  contribution. The architecture should not get in the way of letting developers and user solve their internal
  needs, whatever they may be.</p>

<p>We track the progress on JIRA using task and subtask. We attempt to try project velocity (defined as a ration of our
  estimates to the actual time spent on implementing new features) using JIRA time tracking tools. The content of
  the next release can be roughly assessed by checking JIRA road-map report.</p>

<p>We develop new functionality by implementing small self contained task. We add features incrementally, one at a
  time without breaking existing code. At any given moment we are not further than 4 weeks from having a release
  quality product. All architectural changes are driven by user visible changes.</p>

<h2>The Configuration Server Components</h2>

<p><img src="images/server-information-flow.gif" alt="server information flow"/> Figure 1 - Configuration Server Context Diagram</p>

<p>The Configuration Server is composed of several processes or
components.  It was designed in this manner to improve robustness and
to allow the different components to run on separate hosts to improve
scalability.</p>


<p>Configuration Server Components below describes the main
responsibilities of each component.</p>

<ol>

  <li><strong>Profile Generation Server (PGS)</strong> - Provides
interfaces for users and external systems to interact with SIPxchange.

<ul>

  <li>Managing the organization and administration of business objects
such as users, devices, user groups, applications, etc.</li>

  <li>The generation of device profiles.</li>
      
  <li>Installation and management of phone applications. </li>
      
  <li>Servicing requests from PPS.</li>
      
  <li>Configuration of the Comm. Server services.</li>
      
  <li>Allows the administrators to stop, start and restart the other
SIPxchange servers.</li>
      
  <li>The PGS produces datasets that are used to provision the other
SIPxchange servers (credentials, permissions, etc.)</li>

  <li>Downloading Pingtel xpression applications from Pingtel into
customers own SIPxchange installations.</li>

</ul>
</li>
      
  <li><strong>Profile Writer Server (PWS)</strong> - The profile
writer manages the writing of the device profiles onto various Content
Delivery Servers.</li>

  <li><strong>Profile Publisher Server (PPS)</strong> (formerly
Software Delivery Server - SDS) - provides the SIP client
functionality annd manages enrollments, notifications and profile
retrieval.</li>

  <li><strong>Content Delivery Servers (CDS)</strong> - The CDS
servers are off-the-shelf servers that the phones use to retrieve the
profiles from.  We currently support HTTP(S) using Apache and TFTP
using the Linux TFTP server.</li>
      
</ol>

<h3>Profile Generation Server (PGS)</h3>

<p><img src="images/profilegenerator-design.gif" alt="profile generator design"/></p>

<p>Figure 2 - PGS Component Design shows the layers that exist in the
PGS.  They can be thought of in terms of tiers.  There are the
presentation, business and integration and persistence tiers.</p>


<h3>Profile Writer Server PWS</h3>

<img src="images/profilewriter-design.gif" alt="profilewriter design"/>

<p>Figure 3 - Profile Writer Design</p>

<p>The Profile Writer is a relatively simple process which takes
requests from the PGS to store and delete profiles and informs the PPS
when these events occur.  Figure 3 - Profile Writer Design shows the
basic design of the PW.  Requests (remote method invocations) are
received over RMI from the PGS.  Currently only two methods are used,
write and delete profile.</p>

<p>The main thread is responsible for handing incoming requests over RMI, it places Command objects on a queue for
  the worker thread to process. All synchronization between these threads is done on this queue. The worker thread
  is used to write/delete profiles and to send method calls over RMI to the PPS.</p>

<p>When the PW gets a request to write a profile it determines what
type of device the profile belongs to (Pingtel or Cisco) and then uses
this information to decide which CDS to put the profile on.  The
profile is sent as a byte stream via one of the method parameters.
Using RMI enables us to put the PGS and PW on separate servers if
required.  Once the PW has written the profile to the appropriate CDS
it informs the PPS (using RMI) that a new profile is available.  For
Pingtel devices the PPS will then send a SIP NOTIFY message to the
device who this profile belongs to if that device has previously
enrolled with the PPS.  For Cisco devices the PPS sends a NOTIFY /
check-sync message to the device and the device will reboot (which
causes it to fetch the new profile from the TFTP CDS).</p>

<h3>Profile Publisher Server (PPS)</h3>

<img src="images/profilepublisher-design.gif" alt="profile publisher design"/>

<p>Figure 4 - Context Diagram shows the architecture of the
ProfilePublisher.  The main application logic is contained in the Java
Code shown at the top.  This code is responsible for:</p>

<ul>

  <li>(Re)Enrolling (Pingtel only) devices upon receipt of SIP
SUBSCRIBE messages.  A subscription context is put in the PPS database
for each enrolled device profile type (user, device and
application)</li>
       
  <li>Removing expired enrollments.  All enrollments have a defined
enrollment period, after this time the device is un-enrolled from the
PPS.</li>
      
  <li>Sending SIP NOTIFY messages to enrolled devices.  This occurs
when a device first enrolls with the PPS and whenever the PPS is told
about the availability of a new profile from the Profile Writer.</li>
      
  <li>Sending SIP NOTIFY (check sync) messages to both Pingtel and
Cisco devices.  This happens when the user requests that devices
reboot from the user interface either explicitly or implicitly when
profiles are generated for Cisco devices</li>
      
  <li>The SIP Stack is the same SIP stack that we use in other parts
of the Pingtel products.  The PPS uses the Java Native Interface (JNI)
to interact with it.</li>
</ul>


<img src="profilepublisher-detail-design.gif" alt="profile publisher detailed design"/>

<p>Figure 5 - PPS Design shows more details of the Java Code shown in
Figure 4 - PPS Context Diagram.  The main thread handles remote method
invocations from the Profile Writer, creating and en-queuing Command
objects onto the command queue.  The Profile Listener Worker thread
de-queues these command objects from the command queue and executes
them.</p>

<p>These command objects are based around notifying devices that they
have new profiles or should restart.  The command objects use the SIP
stack via JNI to send SIP messages to devices.  The command pattern
provides extensibility so as new uses are found for the PPS new
command classes can be added.</p>

<p>The Subscription Listener thread registers with the SIP stack for
interest in SUBSCRIBE messages.  When it receives those it creates or
updates a subscription context in the PPS database.  This subscription
context is used extensively by the Command objects to find out where
to send SIP messages.  The RDBMS is used as the means of
synchronization between the Profile Worker Listener (Command objects),
Subscription Listener and Housekeeper threads. </p>

<p>The Housekeeper thread is used to reap expired enrollments from the
PPS database.  It wakes up periodically and deletes old records. </p>

<h3>Content Delivery Servers CDS</h3>

<p>The CDS are off the shelf servers which the devices use to fetch
their profiles.  We currently support TFTP (used by the Cisco 79XX and Polycom)
and HTTP (used by the Pingtel phones).</p>


<span id="lastmodified">
<!-- hhmts start -->
Last modified: Thu Jun  9 15:34:20 EDT 2004
<!-- hhmts end -->
</span>

</body>
</html>
